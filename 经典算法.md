## 数组/字符串

### 1、合并两个有序数组

题号：88

```js
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
```

解题方法：逆向双指针

思路：

> 设置两个指针 p1 和 p2，代表当前正在处理中的 nums1 或 nums2 的位置。每次应用后减 1
>
> 以及当前正在处理的元素位置 tail，每次成功处理后减 1
>
> 遍历比较两者大小，大的数往 tail 所代表的 nums 的位置存放

```js
const merge = (nums1: number[], m: number, nums2: number[], n: number) => {
  let tail = m + n - 1; //指向当前处理的值（从后往前）
  let p1 = m - 1; //指针指向nums1正在处理的元素
  let p2 = n - 1; //指针指向nums2正在处理的元素

  // 当p1或p2大于-1，说明有数组未完成遍历
  while (p1 > -1 || p2 > -1) {
    let cur: number; // 当次遍历的结果

    // 当p1或p2等于-1，说明对应的数组已经遍历完成
    if (p1 === -1) {
      cur = nums2[p2--];
    } else if (p2 === -1) {
      cur = nums1[p1--];
    }
    // 取出较大的值，当相等时，取任意一个数组的值
    else if (nums1[p1] > nums2[p2]) {
      cur = nums1[p1--];
    } else {
      cur = nums2[p2--];
    }

    // 将值从后往前赋予num1
    nums1[tail--] = cur;
  }

  return nums1;
};
```



### 2、移除数组

题号：27

```js
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2,_,_]
```

解题方法：双指针

注意点：

1、更改 `nums` 数组，使 `nums` 的前 `k` 个元素包含不等于 `val` 的元素。

2、`nums` 的其余元素和 `nums` 的大小并不重要

解题思路：

1、依次遍历数组，将不同于val的值往前挪即可。使用curIndex记录当前处理的元素，也代表当前与val不同的元素个数

```js
function removeElement(nums: number[], val: number): number {
  let curIndex: number = 0; // curIndex记录当前处理的元素，也代表当前与val不同的元素个数
  for (let i = 0; i < nums.length; i++) {
    // 找不同
    if (nums[i] !== val) {
      nums[curIndex++] = nums[i];
    }
  }
  return curIndex;
}
```



### 3、删除有序数组中的重复项

题号：26

解题方法： 双指针

解题思路：题目仅检验左边数组的正确性。利用 slow 指针指向当前处理的元素（由于第 1 位始终是最小的，所以 slow = 1 ），fast 指针从第二项开始遍历，如果大于前一项则将其替换掉 slow 的位置的元素

```js
function removeDuplicates(nums: number[]): number {
  let slow = 1;
  for (let fast = 1; fast < nums.length; fast++) {
    if (nums[fast - 1] < nums[fast]) {
      nums[slow++] = nums[fast];
    }
  }
  return slow; //最后一个不重复元素位移后，slow进行了++，所以nums中的重复元素为slow
}
```



###  4、删除有序数组中的重复项 2

题号：80

解题方法：双指针

解题思路：定义快慢双指针，慢指针指向当前需要处理的元素(由于前两项要么不同要么相同，符合条件，可以从第三项处理起)，快指针进行遍历。当且仅当 nums[fast] = nums[slow - 1] = nums[slow - 2]，说明当前的 slow 值已存在两次，可以不进行处理。

```js
function removeDuplicates(nums: number[]): number {
  if (nums.length < 2) return nums.length;

  let slow = 2;
  for (let fast = 2; fast < nums.length; fast++) {
    if (nums[slow - 2] !== nums[fast] || nums[slow - 1] !== nums[fast]) {
      nums[slow] = nums[fast];
      slow++;
    }
  }
  return slow;
}
```



### 5、多数元素

题号：169

注意：多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素

解决方法：统计次数、排序、投票算法

**方式一 ： 排序**

解题思路：既然总数一定大于数组 length 的 1/2，那么通过排序后中位数所在的位置一定就是众数。偶数长度：n / 2; 奇数长度：Math.floor(n/2)

```js
function majorityElement(nums: number[]): number {
  nums.sort((a, b) => a - b);
  return nums[Math.floor(nums.length / 2)];
}
```

**方式二：投票算法**（推荐）

解题思路：如果把众数记为 +1，把其他数记为 -1，将它们全部加起来，显然和大于 0，从结果本身可以看出众数比其他数多(对照生活中的投票现象会变得很好理解)

```js
function majorityElement(nums: number[]): number {
  let candidate: number | null = null; //假设为众数，标记为赞成票
  let count = 0; //目前赞成的分数
  for (let i = 0; i < nums.length; i++) {
      // 当赞成票count为0，重新标记赞成票
    if (count === 0) candidate = nums[i];
    candidate === nums[i] ? count++ : count--; //赞成分数+1；不赞成-1
  }
  return candidate as number;
}
```



### 6、轮转数组

题号：189

解决方法：新建一个数组存储、翻转数组

**方式一：翻转数组**

解题思路：将原数组按照不同的位置翻转 3 次

<img src="D:\code\mime\mzlin-notes\img\经典算法\轮转数组.jpg" style="zoom:67%;" />

```js
// 反转数组，指定start与end位置
const reverse = (nums: number[], start: number, end: number): void => {
  while (start < end) {
    let temp = nums[start];
    nums[start] = nums[end];
    nums[end] = temp;
    start++;
    end--;
  }
};

function rotate(nums: number[], k: number): void {
  k = k % nums.length;
  reverse(nums, 0, nums.length - 1); //反转整个数组
  reverse(nums, 0, k - 1); // 反转前k个
  reverse(nums, k, nums.length - 1); // 反转后 n-k 个
}
```



###  7、买股票的最佳时机

题号：121

解决方法：双循环暴力解法、一次遍历

**方式一：一次遍历**

解题思路：最大的收益永远符合以下规则：历史最低价与后来天数中的最高阶的差值。所以只要在一次循环中匹配到最低价，再往后遍历到`profit < prices[i] -minPrice`即是最大收益

```js
function maxProfit(prices: number[]): number {
  let minPrice = prices[0]; //假设历史最低价格
  let profit = 0; //最大收益

  // 找低价位，往后循环匹配更新收益profit 
  for (let i = 0; i < prices.length; i++) {
    if (prices[i] < minPrice) {
        // 重新更新最低价
      minPrice = prices[i];
    } else if (prices[i] - minPrice > profit) {
        // 更新最大收益
      profit = prices[i] - minPrice;
    }
  }

  return profit;
}
```



### 8、买股票的最佳时机 2

题号：122

解决方法：遍历计算差值

解题思路：最大利润为每次能够取得的差值相加

```js
function maxProfit(prices: number[]): number {
  let result = 0;
  for (let i = 1; i < prices.length; i++) {
    if (prices[i - 1] < prices[i]) {
      result += prices[i] - prices[i - 1];
    }
  }
  return result;
}
```



###  H 指数

题号：274

解决方法：排序

解题思路：排序并反向遍历，当 arr[i]>h 时，h++。否则返回 h

```js
function hIndex(citations: number[]): number {
  citations.sort((a, b) => a - b);
  let h = 0,
    n = citations.length - 1;
  while (n >= 0 && citations[n] > h) {
    h++;
    n--;
  }
  return h;
}
```

### 跳跃游戏

题号：55

解决方法：贪心算法

解题思路：遍历数组，计算可到达元素的向右跳的最大值(i + nums[i])。遍历过程中如何确定元素可达：i <= rightMost。当且仅当向右跳的最大元素 rightMost 大于数组的长度时，说明最后一个元素可达

```js
function canJump(nums: number[]): boolean {
  let rightMost = 0; //当前向右跳的最大值
  for (let i = 0; i < nums.length; i++) {
    if (i <= rightMost) {
      rightMost = Math.max(rightMost, i + nums[i]);
      if (rightMost >= nums.length - 1) return true;
    }
  }
  return false;
}
```

### 跳跃游戏 2

题号：45

解决方法：贪心算法

方式一：贪心算法（较难理解）

1、每次找到可到达的最远位置，就可以在线性时间内得到最少的跳跃次数。(每次在上次能跳到的范围（end）内选择一个能跳的最远的位置（也就是能跳到 maxPostion 位置的点）作为新的范围（end))

2、循环过程中，每当循环至边界 end(每次能跳跃的最远距离)，step 跳跃次数+1。

3、为避免最后一次跳跃距离正好等于最后一个位置，导致 step 多了一次。所以遍历时直接跳过最后一次

```js
function jump(nums) {
  debugger;
  let end = 0; // 上次跳跃可达范围右边界（下次的最右起跳点）
  let maxPostion = 0; // 目前能跳到的最远位置
  let steps = 0; //跳跃次数
  for (let i = 0; i < nums.length - 1; i++) {
    maxPostion = Math.max(maxPostion, i + nums[i]);
    // 到达上次跳跃能到达的右边界了
    if (i === end) {
      end = maxPostion; // 目前能跳到的最远位置变成了下次起跳位置的有边界
      steps++; // 进入下一次跳跃
    }
  }
  return steps;
}
```

### O(1) 时间插入、删除和获取随机元素

题号：380

解决方法：数组与哈希

解题思路：在进行插入操作时，通过 map 记录插入元素的位置，方便后续进行删除操作；在进行删除时，将数组元素与最后一个元素交换，通过 pop 删除。同时需要更新 map 中的数据；在返回随机元素时，利用 Math.random()\*nums.length 向下取整，获取 nums 区间中的随机数

```js
var RandomizedSet = function () {
  this.nums = [];
  this.map = new Map();
};

RandomizedSet.prototype.insert = function (val) {
  if (this.map.has(val)) return false;
  const index = this.nums.length;
  this.map.set(val, index);
  this.nums.push(val);
  return true;
};

RandomizedSet.prototype.remove = function (val) {
  if (this.map.has(val)) {
    let index = this.map.get(val);
    this.nums[index] = this.nums[this.nums.length - 1];
    this.nums.pop();
    //更新map
    this.map.set(this.nums[index], index);
    this.map.delete(val);
    return true;
  } else {
    return false;
  }
};

RandomizedSet.prototype.getRandom = function () {
  if (this.nums.length === 1) return this.nums[this.nums.length - 1];
  else if (this.nums.length === 0) return false;
  else {
    const randomIndex = Math.floor(Math.random() * this.nums.length);
    return this.nums[randomIndex];
  }
};
```

### 除自身以外数组的乘积

题号：238

解决方法：当前元素的前缀之积 \* 当前元素的后缀之积 = 结果

解题思路：当前元素的前缀之积 \* 当前元素的后缀之积 = 除自身以外数组的乘积。遍历数组获取到每个元素的前缀之积 L，倒序遍历数组获取到每个元素的后缀之积，LR 两个数组对应位置元素相乘即时 answer（为了减少时间空间复杂度，可以将 L 的思想直接在 answer 上直接实现，减少了一个数组的空间和一次循环）

```js
function productExceptSelf(nums: number[]): number[] {
  const answer: number[] = [];
  for (let i = 0; i < nums.length; i++) {
    if (i === 0) answer[i] = 1;
    else answer[i] = answer[i - 1] * nums[i - 1];
  }

  let R: number[] = [];
  for (let i = nums.length - 1; i >= 0; i--) {
    if (i === nums.length - 1) {
      R[i] = 1;
      answer[i] = 1 * answer[i];
    } else {
      R[i] = R[i + 1] * nums[i + 1];
      answer[i] = R[i] * answer[i];
    }
  }
  return answer;
}
```

### 加油站

题号：134

> 注：可通过 i % n 实现循环。例如数组 n 等于 5，3%5 等于 3，6%5 则等于 1，从而实现循环

实现思路：暴力双循环

```js
function canCompleteCircuit(gas: number[], cost: number[]): number {
  let n = gas.length;
  //考虑从每一个点出发
  for (let i = 0; i < gas.length; i++) {
    let j = i;
    let remain = gas[i];
    //当前剩余的油能否到达下一个点
    while (remain - cost[j] >= 0) {
      remain = remain - cost[j] + gas[(j + 1) % n];
      j = (j + 1) % n;
      // 回到起点
      if (j === i) {
        return i;
      }
    }
  }
  return -1;
}
```

### 最长公共前缀

题号：14

解决方法：双循环

解题思路：每次截取 strs 中元素的一位，依次对比。如果当次循环中都相同，那么最终结果加上这个值，否则直接停止整个循环

```js
function longestCommonPrefix(strs: string[]): string {
  if (strs[0].length === 0) return "";
  let result = "";
  let end = strs[0].length - 1; //第一个元素最大的索引
  let index = 0; //记录当前比较的索引

  while (index <= end) {
    let str = strs[0][index];
    for (let i = 0; i < strs.length; i++) {
      // 当不存在当值，或者对比的值不相同，停止整个循环
      if (!strs[i][index] || strs[i][index] !== str) {
        str = "";
        index = end + 1;
        break;
      }
    }
    result += str;
    index++;
  }

  return result;
}
```



### 三数之和

题号：15

实现方法：暴力三次循环、三指针

解题思路：对数组进行排序，遍历数组。并以left和right分别指定当前遍历索引k的下一项和数组最后一项。在当次循环中不断判断left和right是否有符合的结果与nums[k]相加等于0

```js
function threeSum(nums) {
  const result = [];
  nums = nums.sort((a, b) => a - b);

  for (let k = 0; k < nums.length - 2; k++) {
    if (nums[k] > 0) break; // 意味着三数相加必定大于0
    if (k > 0 && nums[k] == nums[k - 1]) continue; // 已经将 nums[k - 1] 的所有组合加入到结果中,避免重复
    let left = k + 1; // 小值
    let right = nums.length - 1; // 大值

    while (left < right) {
      let sum = nums[k] + nums[left] + nums[right];
      if (sum < 0) {
        // 跳过相同值，避免记录到重复组合
        while (left < right && nums[left] == nums[++left]);
      } else if (sum > 0) {
        while (left < right && nums[right] == nums[--right]);
      } else {
        result.push([nums[k], nums[left], nums[right]]);
        while (left < right && nums[left] == nums[++left]);
        while (left < right && nums[right] == nums[--right]);
      }
    }
  }

```



### 反转字符串中的单词

题号：151

解决方法：队列

解题思路：依次取出每个单词，加入数组的开头

```js
function reverseWords(s: string): string {
  let result = [];
  let left = 0,
    right = s.length - 1;

  // 去除开头空格
  while (left <= right && s[left] === " ") {
    left++;
  }

  // 去除末尾空格
  while (left <= right && s[right] === " ") {
    right--;
  }

  // 存储每一个单词块
  let word = "";

  for (left; left <= right; left++) {
    // 非空格时，添加至word
    if (s[left] !== " " && left !== right) {
      word += s[left];
    } else {
      if (left === right) {
        word += s[left];
      }
      if (word !== "") {
        // 将完整的单词块添加到数组的首位
        // @ts-ignore
        result.unshift(word);
        word = "";
      }
    }
  }

  return result.join(" ");
}
```



### Z字形变换

题号：6

解题思路：根据行数初始化一个数组，遍历字符串，依次将遍历到的字符填充到数组对应的位置。当遍历到了需要向上的位置（down为false）时，将填充的位置（index）依次减少。当遍历到了需要向下的位置时（此时index为0），将index一次增加（down为true）

```js
function convert(s: string, numRows: number): string {
  if (numRows <= 1) return s;
  let arr: string[] = [];
  for (let i = 0; i < numRows; i++) {
    arr[i] = "";
  }

  let down = true;
  let index = 0;

  for (let i = 0; i < s.length; i++) {
    if (index === 0) down = true;
    arr[index] += s[i];

    if (index === arr.length - 1 || !down) {
      down = false;
      index--;
    } else {
      index++;
      down = true;
    }
  }

  let result = "";
  for (let i = 0; i < arr.length; i++) {
    result += arr[i];
  }

  return result;
}
```





### 单词规律

题号：290

实现方法：hash映射

解题思路：创建两个映射，分别保存规律映射单词，单词映射规律。遍历规律或单词，当出现已存在的映射关系时，判断是否符合之前存的两个映射关系

```js
function wordPattern(pattern, s) {
  const words = s.split(" ");
  const pMap = {};
  const sMap = {};
  if (pattern.length !== words.length) return false;

  for (let i = 0; i < words.length; i++) {
    let skey = words[i];
    let pkey = pattern[i];

    if (
      (sMap.hasOwnProperty(skey) && sMap[skey] !== pkey) ||
      (pMap.hasOwnProperty(pkey) && pMap[pkey] !== skey)
    ) {
      return false;
    }

    sMap[skey] = pkey;
    pMap[pkey] = skey;
  }
  return true;

```



### 盛水最多的容器

题号：11

解题方法：暴力双循环，双指针

解题思路：双指针置于两端left right，判断两边谁是短板，短板则向内移动，直至两个指针重叠为止。这个过程中不断更新最大值

```js
function maxArea(height: number[]): number {
  let left = 0;
  let right = height.length - 1;
  let maxArea = 0;
  while (left !== right) {
    // 更新最大值
    let newArea = Math.min(height[left], height[right]) * (right - left);
    maxArea = newArea > maxArea ? newArea : maxArea;

    // 向内移动短板
    if (height[left] < height[right]) {
      left++;
    } else {
      right--;
    }
  }

  return maxArea;
}

```





### 快乐数

题号：202

解题方法：用哈希集合检测循环

解题思路：创建一个函数用于数位分离求平方和，当函数生成的新值不存在于哈希中时，添加它；存在时则说明进入了一个循环中

```js
var isHappy = function (n) {
  // 获取下一个值
  let getNext = function (n) {
    return n
      .toString()
      .split("")
      .map((i) => i ** 2)
      .reduce((a, b) => a + b);
  };

  const set = new Set();
  // 当set中存在了n，说明进入了死循环
  while (n !== 1 && !set.has(n)) {
    set.add(n);
    n = getNext(n);
  }

  // 当n不能再进入循环时，说明要么n等于1，或者n已经存在于set
  return n === 1;
};

```

### 最长连续序列

题号：128

解题方法：哈希表

解题思路：解题思路在于能够通过`num - 1`来判断num是否是连续的第一个数，如果是不断的推衍这个数加一是否存在于set中，在这个过程中不断更新最大长度

```js
function longestConsecutive(nums: number[]): number {
  const set = new Set<number>();
  let res = 0;
  for (let num of nums) {
    set.add(num);
  }

  for (let num of set) {
    // 说明此num是连续的第一个数
    if (!set.has(num - 1)) {
      let currentMaxLen = 1; //记录当前数字的最大连续长度
      let currentNum = num; //当前遍历的num值（不断+1）

      // 如果set中有连续的数+1
      while (set.has(currentNum + 1)) {
        currentMaxLen++;
        currentNum++;
      }

      // 不断更新最大长度
      res = Math.max(res, currentMaxLen);
    }
  }
  return res;
}
```



### [搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

题号：35

解题方法：二分查找

```ts
function searchInsert(nums: number[], target: number): number {
  let left = 0;
  let right = nums.length - 1;

  while (left <= right) {
    const mid = ((right - left) >> 1) + left; //或者 Math.floor((right + left) / 2 )
    if (target === nums[mid]) {
      // 匹配到了目标值，直接返回结果
      return mid;
    } else if (target < nums[mid]) {
      // target在左半部分
      right = mid - 1;
    } else {
      // target在右半部分
      left = mid + 1;
    }
  }

  // 为什么返回left
  // 假设最后只剩一个元素，如[1],target=0或3，最终返回left即可
  // 假设最后剩两个元素，如[1, 3],target=0或2，最终返回left即可
  return left;
}

```



### 搜索二维矩阵

题号：74

解题方法：两次二分查找

解题思路：第一次二分查找出目标元素所在的一维数组，第二次匹配出是否存在目标元素

```ts
function searchMatrix(matrix: number[][], target: number): boolean {
  // 匹配对应的一维数组
  const rowIndex = binarySearchFirstColumn(matrix, target);
  if (rowIndex < 0) return false;
  return binarySearch(matrix[rowIndex], target);
}

// 二分查找数组第一层，匹配到目标元素所在的数组
const binarySearchFirstColumn = (
  matrix: number[][],
  target: number
): number => {
  let left = -1;
  let right = matrix.length - 1;
  while (left < right) {
    let mid = Math.floor((right - left + 1) / 2) + left;
    if (matrix[mid][0] === target) {
      return mid;
    } else if (target < matrix[mid][0]) {
      right = mid - 1;
    } else {
      left = mid;
    }
  }

  return left;
};

// 二分查找
const binarySearch = (arr: number[], target: number): boolean => {
  let left = 0;
  let right = arr.length - 1;
  while (left <= right) {
    const mid = Math.floor((right - left) / 2) + left;
    if (arr[mid] === target) {
      return true;
    } else if (arr[mid] > target) {
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }
  return false;
};
```



### [寻找峰值](https://leetcode.cn/problems/find-peak-element/)

题号：74

解题方法：二分查找、直接查找数组中的最大值

解题思路：利用二分查找结合爬山的思想，不断判断那边是上山方向，最终找到峰值

```ts
//判断中点左右哪边是上坡，往上坡方向走
function findPeakElement(nums: number[]): number {
  let left = 0;
  let right = nums.length - 1;
  while (left < right) {
    const mid = Math.floor((right - left) / 2) + left;

    // 当 nums[mid] > nums[mid + 1]时，说明往左走是上坡
    if (nums[mid] > nums[mid + 1]) {
      right = mid;
    } else {
      // 往右走是上坡
      left = mid + 1;
    }
  }

  return left;
}
```

### 在排序数组中查找元素的第一个和最后一个

题号：34

解题方法：两次二分查找

解题思路：分为两个不同的二分函数进行查找，第一个函数查找第一个等于target的值，第二个函数查找最后一个等于target的值

```ts
function searchRange(nums: number[], target: number): number[] {
  let first = -1;
  let last = -1;

  // 查找出第一个值
  const binarySearchFirst = (nums: number[], target: number) => {
    let right = nums.length - 1;
    let left = 0;
    while (left <= right) {
      const mid = Math.floor((right + left) / 2);
      if (nums[mid] === target) {
        right = mid - 1; // 重点：继续向前匹配，直到找到第一个
        first = mid;
      } else if (target < nums[mid]) {
        right = mid - 1;
      } else {
        left = mid + 1;
      }
    }
  };

  // 查找出最后一个值
  const binarySearchLast = (nums: number[], target: number) => {
    let right = nums.length - 1;
    let left = 0;
    while (left <= right) {
      const mid = Math.floor((right + left) / 2);
      if (nums[mid] === target) {
        left = mid + 1; // 重点：继续向后匹配，直到找到第一个
        last = mid;
      } else if (target < nums[mid]) {
        right = mid - 1;
      } else {
        left = mid + 1;
      }
    }
  };

  binarySearchFirst(nums, target);
  binarySearchLast(nums, target);

  return [first, last];
}
```

