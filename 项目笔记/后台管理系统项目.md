# 后台管理系统项目

# 一、项目搭建

### 1.1 基本配置

**创建项目**

1、使用脚手架创建vue3-cms项目`vue create vue3-cms`

选择：`Choose Vue version、Babel、CSS Pre-processors、Linter / Formatter`

项目使用到的router、vuex将手动配置，linter选择ESLint + Prettier



**集成editorconfig配置**

editorconfig有助于为不同IDE编辑器上处理同一项目的多个开发人员维护一致的编码风格

创建.editorconfig文件

```yaml
    # http://editorconfig.org

    root = true

    [*] # 表示所有文件适用
    charset = utf-8 # 设置文件字符集为 utf-8
    indent_style = space # 缩进风格（tab | space）
    indent_size = 2 # 缩进大小
    end_of_line = lf # 控制换行类型(lf | cr | crlf)
    trim_trailing_whitespace = true # 去除行首的任意空白字符
    insert_final_newline = true # 始终在文件末尾插入一个新行

    [*.md] # 表示仅 md 文件适用以下规则
    max_line_length = off
    trim_trailing_whitespace = false
```

在vscode中，需要安装一个插件来读取这个文件 `EditorConfig for VS Code`



补充：打开vscode 的保存`ctrl s`自动格式化选项Format On Save

### 1.2 使用prettier工具

Prettier 是一款强大的代码格式化工具，支持 JavaScript、TypeScript、CSS、SCSS、Less、JSX、Angular、Vue、GraphQL、JSON、Markdown 等语言，基本上前端能用到的文件格式它都可以搞定，是当下最流行的代码格式化工具。

1、安装prettier

```shell
npm install prettier -D
```

2、配置.prettierrc文件：

* useTabs：使用tab缩进还是空格缩进，选择false；
* tabWidth： tab是空格的情况下，是几个空格，选择2个；
* printWidth：当行字符的长度，推荐80，也有人喜欢100或者120；
* singleQuote：使用单引号还是双引号，选择true，使用单引号；
* trailingComma：在多行输入的尾逗号是否添加，设置为 `none`；
* semi：语句末尾是否要加分号，默认值true，选择false表示不加；

```json
{
  "useTabs": false,
  "tabWidth": 2,
  "printWidth": 80,
  "singleQuote": true,
  "trailingComma": "none",
  "semi": false
}
```



3、创建.prettierignore忽略文件

```
/dist/*
.local
.output.js
/node_modules/**

**/*.svg
**/*.sh

/public/*
```

4、VSCode需要安装prettier的插件

5.测试prettier是否生效

* 测试一：在代码中保存代码；
* 测试二：配置一次性修改的命令；

在package.json中配置一个scripts：

```json
    "prettier": "prettier --write ."
```

当运行`npm run prettier`时，除了被忽略的文件，其余文件都会被格式化



注：ESLint与prettier都是规范代码，两个有时会有一些冲突。比如在prettier中规定单引号，在ESLint规定双引号就会产生冲突，需要进行配置



### 1.3 使用ESLint检测

1、在前面创建项目的时候，我们就选择了ESLint，所以Vue会默认帮助我们配置需要的ESLint环境。

2、VSCode需要安装ESLint插件：

3、解决ESLint和prettier冲突的问题：

安装插件：（vue在创建项目时，如果选择prettier，那么这两个插件会自动安装）

```shell
npm i eslint-plugin-prettier eslint-config-prettier -D
```

添加prettier插件：

```json
  extends: [
    "plugin:vue/vue3-essential",
    "eslint:recommended",
    "@vue/prettier",
    'plugin:prettier/recommended'
  ],
```



### 1.4 vue.config.js配置文件

```js
    const path = require('path')

    module.exports = {
  //打包存放的文件夹
  outputDir: './bulid',
  // 起别名
  configureWebpack: (config) => {
    config.resolve.alias = {
      '@': path.resolve(__dirname, 'src'),
      components: '@/components'
    }
  }
}
```

当我们导入path模块时，ESLint会报错，默认不让使用require。但是我们项目确实需要，这个时候就可以改变ESLint的规则。

鼠标移动到require关键字上，会显示ESLint的规则（@typescript-eslint/no-var-requires），进入eslintrc.js进行修改

```js
  rules: {
    'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
    'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
    "@typescript-eslint/no-var-requires": 'off'
  }
}

```

注：修改配置后，应该重新运行项目



### 1.5 配置vue-router

安装vue-router的最新版本：

```shell
npm install vue-router@next
```

创建router对象：

```ts
import { createRouter, createWebHashHistory } from 'vue-router'

const routes = [
  {
    path: '/',
    redirect: '/main'
  },
  {
    path: '/main',
    component: () => import('../views/main/main.vue')
  },
  {
    path: '/login',
    component: () => import('../views/login/login.vue')
  }
]

const router = createRouter({
  routes,
  history: createWebHashHistory()
})

export default router
```

安装router：

```ts
import router from './router'

createApp(App).use(router).mount('#app')
```

在App.vue中配置跳转：

```html
<template>
  <div id="app">
    <router-link to="/login">登录</router-link>
    <router-link to="/main">首页</router-link>
    <router-view></router-view>
  </div>
</template>
```



### 1.6 配置vuex

安装vuex：

```shell
npm install vuex@next
```

创建store对象：

```ts
import { createStore } from 'vuex'

const store = createStore({
  state() {
    return {
      name: 'linming'
    }
  }
})

export default store
```

安装store：

```ts
createApp(App).use(router).use(store).mount('#app')
```

在App.vue中使用：

```html
<h2>{{ $store.state.name }}</h2>
```



### 1.7 element-plus集成

Element Plus，一套为开发者、设计师和产品经理准备的基于 Vue 3.0 的桌面端组件库：

* element-plus正是element-ui针对于vue3开发的一个UI组件库；
* 它的使用方式和很多其他的组件库是一样的，其他类似于ant-design-vue、NaiveUI、VantUI都是差不多的；

安装element-plus

```shell
npm install element-plus
```



**全局使用**



一种引入element-plus的方式是全局引入，代表的含义是所有的组件和插件都会被自动注册：

```js
import ElementPlus from 'element-plus'
import 'element-plus/lib/theme-chalk/index.css'


createApp(App).use(router).use(store).use(ElementPlus).mount('#app')
```

```vue
//使用
    <el-button>ui按钮</el-button>
    <el-button type="primary">ui按钮</el-button>
    <el-button type="danger">ui按钮</el-button>
```



**按需引用**

也就是在开发中用到某个组件对某个组件进行引入：

```vue
<template>
  <div id="app">
    <router-link to="/login">登录</router-link>
    <router-link to="/main">首页</router-link>
    <router-view></router-view>

    <h2>{{ $store.state.name }}</h2>

    <el-button>默认按钮</el-button>
    <el-button type="primary">主要按钮</el-button>
    <el-button type="success">成功按钮</el-button>
    <el-button type="info">信息按钮</el-button>
    <el-button type="warning">警告按钮</el-button>
    <el-button type="danger">危险按钮</el-button>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

import { ElButton } from 'element-plus'

export default defineComponent({
  name: 'App',
  components: {
    ElButton
  }
})
</script>

<style lang="less">
</style>
```

但是我们会发现是没有对应的样式的，引入样式的方式：

官方推荐：全局引用样式

`import 'element-plus/dist/index.css'`



但是这里依然有个弊端：

* 这些组件我们在多个页面或者组件中使用的时候，都需要导入并且在components中进行注册；
* 所以我们可以将它们在全局注册一次；

```ts
//在main.js中
import {
  ElButton,
  ElTable,
  ElAlert,
  ElAside,
  ElAutocomplete,
  ElAvatar,
  ElBacktop,
  ElBadge,
} from 'element-plus'

const app = createApp(App)

const components = [ //将所有需要用到的ui封装成一个数组
  ElButton,
  ElTable,
  ElAlert,
  ElAside,
  ElAutocomplete,
  ElAvatar,
  ElBacktop,
  ElBadge
]

for (const cpn of components) {
  app.component(cpn.name, cpn) //将所有的ui组件，统一注册
}
```

但是如果将所有的代码都写在入口文件显然是不好的，可以将这些用到的ui全局注册抽离出去

建立global文件夹

```ts
//global/index.ts
import { App } from 'vue'
import 'element-plus/dist/index.css'
import {
  ElButton,
  ElForm,
  ElAlert,
  ElAside,
  ElInput,
  ElRadio,
  ElFormItem
} from 'element-plus'
const conponents = [
  ElButton,
  ElForm,
  ElAlert,
  ElAside,
  ElInput,
  ElRadio,
  ElFormItem
] //将所有需要用到的ui封装成一个数组

export function registerApp(app: App): void {
  for (const conponent of conponents) {
    app.component(conponent.name, conponent) //将所有的ui组件，统一注册
  }
}
```

在main.ts直接引用

```ts
import { createApp } from 'vue'
import App from './App.vue'

import { registerApp } from './global'
import router from './router'
import store from './store'

const app = createApp(App)

registerApp(app)
app.use(router)
app.use(store)
app.mount('#app')
```

之后会对global中的index.ts中的代码增加很多其他内容，我们可以将其中的注册ui组件的代码单独抽离出去

```ts
//global/register-element.ts
import { App } from 'vue'
import 'element-plus/dist/index.css'
import {
  ElButton,
  ElForm,
  ElAlert,
  ElAside,
  ElInput,
  ElRadio,
  ElFormItem
} from 'element-plus'
const conponents = [
  ElButton,
  ElForm,
  ElAlert,
  ElAside,
  ElInput,
  ElRadio,
  ElFormItem
] //将所有需要用到的ui封装成一个数组

export default function (app: App): void {
  for (const conponent of conponents) {
    app.component(conponent.name, conponent) //将所有的ui组件，统一注册
  }
}
```

```ts
//global/index.ts
import { App } from 'vue'
import registerElement from './register-element'

export function registerApp(app: App): void {
  registerElement(app)
}
```



## 二、axios集成

### 2.1 基本使用

特点：

功能特点: 

1、在浏览器中发送 XMLHttpRequests 请求

2、在 node.js 中发送 http请求

3、支持 Promise API

4、拦截请求和响应

5、转换请求和响应数据



安装axios：

```shell
npm install axios
```

**基本使用**

1、axios返回一个promise

```js
axios.request({
    method:'GET'
}) 
//等同于
axios.get({
    
})
```

2、promise本身可以有类型

```ts
//例如
new Promise<string>((resolve) => {
    resolve('abc')
}).then((res) => {
    console.log(res.length)
})
//事实上，axios的类型是AxiosResponse<any>
```

3、发送get请求，并传入参数

```ts
axios
  .get('http://httpbin.org/get', {
    params: {
      name: 'ming',
      age: 22
    }
  })
  .then((res) => {
    console.log(res.data)
  })
```

4、发送post请求

```ts
axios
  .post('http://httpbin.org/post', {
    data: {
      name: 'ming',
      age: 22
    }
  })
  .then((res) => {
    console.log(res.data)
  })
```

5、axios的配置选项

```ts
// 全局的配置
axios.defaults.baseURL = 'http://httpbin.org'

//每个请求单独的配置
axios.get('/get', {
  params: {
    name: 'ming',
    age: 22
  }
})
```

6、发送多个请求，一起返回

```ts
//axios.all返回一个数组
axios.defaults.baseURL = 'http://httpbin.org'
axios
  .all([
    axios.get('/get', { params: { name: 'linming', age: 18 } }),
    axios.post('/post', { data: { name: 'linming', age: 18 } })
  ])
  .then((res) => {
    console.log(res[0])
    console.log(res[1])
  })

```



### 2.2 拦截器

分为请求拦截、响应拦截

```ts
// fn1:请求发送成功会执行的函数
// fn2:请求发送失败会执行的函数
axios.interceptors.request.use(fn1,fn2) //请求拦截
axios.interceptors.response.use(fn1,fn2) //响应拦截
```

1、请求拦截

```ts
axios.interceptors.request.use(
  (config) => {
    //具体的拦截操作，比如给请求添加token、添加isLoading动画
    console.log('请求成功拦截~')
    return config
  },

  (err) => {
    console.log('请求发送失败')
    return err
  }
)
```

2、响应拦截

```ts
axios.interceptors.response.use(
  (res) => {
    console.log('响应拦截成功~');
    return res
  },
  (err) => {
    console.log('服务器响应失败');
    return err
  }
)
```



### 2.3 基本封装

1、基本结构

创建service文件夹，并创建index.js作为对外的统一出口。

在service文件夹下创建request文件夹，用来封装axios,在该文件夹下创建index.js

```ts
//service/request/index.js
//axios网络请求封装在这个类中
class LMRequest {} 

export default LMRequest


//service/index.js
//网络请求统一导出出口
import LMRequest from "./request";

export default new LMRequest()


//main.js
//使用网络请求
import LMRequest from './service/index' //封装的axios请求
```



2、创建axios实例，并发送网络请求

为什么要创建实例？因为每次发送的网络请求路径等信息是不相同的。例如`axios.defaults.baseURL = ''`。应当每个实例根据自己的要求有自己的baseURL

```ts
//service/request/index.js

import axios from 'axios'

class LMRequest {
  instance
  constructor(config) {
    //根据外部config创建相应的实例
    this.instance = axios.create(config)
  }
  // 尝试利用实例发送网络请求(在类中创建request网络请求)
  request(config) { 
    this.instance.request(config).then((res) => {
      console.log(res)
    })
  }
}
export default LMRequest


//service/index.js
import LMRequest from './request'

const BASE_URL = 'http://123.207.32.32:8000/'
const TIME_OUT = 10000
// 创建实例，并导出
const lmRequest = new LMRequest({
  baseURL: BASE_URL,
  timeout: TIME_OUT
})

export default lmRequest



//main.js
//使用网络请求

import lmRequest from './service/index' //封装的axios请求
lmRequest.request({
  url: '/home/multidata',
  method: 'GET'
})
```



### 2.4 拦截器封装

封装要求：要求每一个实例都有对应的拦截器，具体要拦截的东西是根据实际业务需求可变的

代码如下：

```ts
//service/index.js
import LMRequest from './request'

const BASE_URL = 'http://123.207.32.32:8000/'
const TIME_OUT = 10000
// 创建实例，并导出
const lmRequest = new LMRequest({
  baseURL: BASE_URL,
  timeout: TIME_OUT,
  interceptors: {
    requestInterceptor: (config) => {
      console.log('请求拦截成功')
      return config
    },
    requestInterceptorCatch: (err) => {
      console.log('请求拦截失败')
      return err
    },
    responseInterceptor: (res) => {
      console.log('响应拦截成功')
      return res
    },
    responseInterceptorCatch: (err) => {
      console.log('响应拦截失败')
      return err
    }
  }
})

export default lmRequest
```

```ts
//request/index.js
import axios from 'axios'


class LMRequest {
  instance: AxiosInstance //实例
  interceptors//拦截器实例

  constructor(config) {
    //根据外部config创建相应的实例
    this.instance = axios.create(config)

    // 根据外部config创建相应的拦截器
    this.interceptors = config.interceptors

    // 请求拦截
    this.instance.interceptors.request.use(
      this.interceptors.requestInterceptor, //成功
      this.interceptors.requestInterceptorCatch //失败
    )

    // 响应拦截
    this.instance.interceptors.response.use(
      this.interceptors.responseInterceptor,
      this.interceptors.responseInterceptorCatch
    )
  }

  // 尝试利用实例发送网络请求
  request(config){
    this.instance.request(config).then((res) => {
      console.log(res)
    })
  }
}

export default LMRequest

```





**添加所有实例都有的拦截器**

```ts
//request/index.js

class LMRequest {
  instance //实例
  interceptors //拦截器

  constructor(config) {
	//省略代码

    // 添加所有实例都有的拦截器
    this.instance.interceptors.request.use(
      (config) => {
        console.log('所有的实例都有的拦截器：请求成功拦截')
        return config
      },
      (err) => {
        console.log('所有的实例都有的拦截器：请求失败拦截')
        return err
      }
    )
    this.instance.interceptors.response.use(
      (res) => {
        console.log('所有的实例都有的拦截器：响应成功拦截')
        return res
      },
      (err) => {
        console.log('所有的实例都有的拦截器：响应失败拦截')
        return err
      }
    )
  }
}

export default LMRequest

```



### 2.5 添加loading

```ts
//request/index.ts


// 显示loading (导入loading需要的组件、ts类型)
import { ElLoading } from 'element-plus'
import { ILoadingInstance } from 'element-plus/lib/el-loading/src/loading.type'

class LMRequest {
  instance: AxiosInstance //实例
  interceptors?: LMRequestInterceptors //拦截器
  loading?: ILoadingInstance

  constructor(config: LMRequestConfig) {
  
    // 添加所有实例都有的拦截器
    this.instance.interceptors.request.use(
      (config) => {
        console.log('所有的实例都有的拦截器：请求成功拦截')
        this.loading = ElLoading.service({
          lock: true,
          text: '正在请求数据...',
          background: 'rgba(0,0,0,0.3)'
        })
        return config
      },
      (err) => {
        console.log('所有的实例都有的拦截器：请求失败拦截')
        return err
      }
    )
    this.instance.interceptors.response.use(
      (res) => {
        console.log('所有的实例都有的拦截器：响应成功拦截')
        // 将loading移除
        setTimeout(() => {
          this.loading?.close()
        }, 1000)
        return res.data
      },
      (err) => {
        console.log('所有的实例都有的拦截器：响应失败拦截')
        // 将loading移除
        this.loading?.close()
        return err
      }
    )
  }

}

export default LMRequest

```



### 三、登录界面

### 3.1 基本搭建

**配置通用的CSS样式**

1、安装`npm install normalize.css`

在main.ts中引用:`import 'normalize.css'`

2、配置base.less并由index.less统一导出

```css
//base.less
body {
  padding: 0;
  margin: 0;
}

html,
body,
#app {
  width: 100%;
  height: 100%;
}


//index.less
//css样式统一导出的文件
@import './base.less';

//main.ts
import 'import '../src/assets/css/index.less''
```



**整体登录面板**

创建login-panel.vue，编写登录面板的相关逻辑

```vue
<template>
  <div class="login-panel">
    <h1>后台管理系统</h1>
    <el-tabs type="border-card" stretch>
        
      <el-tab-pane>
        <template #label>
          <span><i class="el-icon-user-solid"></i> 账号登录</span>
        </template>
        <login-account />   //账号登录的组件
      </el-tab-pane>


      <el-tab-pane>
        <template #label>
          <span><i class="el-icon-mobile-phone"></i> 手机登录</span>
        </template>
        <login-phone />   //手机登录的组件
      </el-tab-pane>

    </el-tabs>
  </div>
</template>
```

注：stretch——标签的宽度是否自撑开

**登录按钮**

登录按钮项放置在login-panel组件中

```vue
<template>
  <div class="login-panel">
    <h1>后台管理系统</h1>
    <el-tabs stretch>
        省略代码...
    </el-tabs>

    <!-- 登录按钮 -->
    <div class="account-control">
      <el-checkbox>记住密码</el-checkbox>
      <el-link type="primary">忘记密码</el-link>
    </div>
    <el-button class="loginBtn" type="primary">立即登录</el-button>
  </div>
</template>
```



**账号登录面板**

创建login-account组件

```vue
<template>
  <div class="login-account">
    <el-form>
      <!-- 账号 -->
      <el-form-item label="账号">
        <el-input v-model="account.name" />
      </el-form-item>

      <!-- 密码 -->
      <el-form-item label="密码">
        <el-input v-model="account.password" show-password />
      </el-form-item>
    </el-form>
  </div>
</template>
```

这里的`account.password、account.name`在setup中已经定义好，`show-password`可以决定输入时是否进行隐藏

**手机登录面板**

创建login-phone组件

```vue
<template>
  <div class="login-phone">
    <el-form>
      <!-- 手机登录 -->
      <el-form-item label="手机号">
        <el-input v-model="phone.num" />
      </el-form-item>

      <!-- 验证码 -->
      <el-form-item label="验证码">
        <div class="verify">
          <el-input v-model="phone.verificationCode" />
          <el-button type="primary" class="getVerifyBtn">获取验证码</el-button>
        </div>
      </el-form-item>
    </el-form>
  </div>
</template>
```



### 3.2 校验规则

在账号登录组件中，利用ui库对用户输入的账号密码进行校验

```vue
<template>
  <div class="login-account">
    <el-form :rules="rules" :model="account">
      <el-form-item label="账号" prop="name">
        <el-input v-model="account.name" />
      </el-form-item>

      <el-form-item label="密码" prop="password">
        <el-input v-model="account.password" />
      </el-form-item>
    </el-form>
  </div>
</template>

<script lang="ts">
import { defineComponent, reactive } from 'vue'

export default defineComponent({
  setup() {
    const account = reactive({
      name: '',
      password: ''
    })

    // 编写规则
    const rules = {
      name: [
        {	
          required: true, //表示是必填的，有显示一个红色小点
          message: '用户名不能为空~',
          trigger: 'blur' //失去焦点时触发
        },
        {
          pattern: /^[a-z0-9]{6,12}$/,
          message: '用户名必须是6-12个字母或者数字',
          trigger: 'blur'
        }
      ],
      password: [
        {
          required: true,
          message: '密码不能为空~',
          trigger: 'blur' //失去焦点时触发
        },
        {
          pattern: /^[a-z0-9]{6,}$/,
          message: '用户名必须是6以上个字母或者数字',
          trigger: 'blur'
        }
      ]
    }
    return {
      account,
      rules
    }
  }
})
</script>
```



**用户输入验证**

1、用户的输入是否符合规则的验证操作在`login-account.vue`中进行（定义了loginAction方法）

2、点击立即登录的按钮在`login-panel.vue`中,所以需要从该组件中获取子组件中的loginAction，当点击发生时，执行loginAction

（点击按钮，触发login-account中的方法）

```vue
<template>
  <div class="login-panel">
    <el-tabs type="border-card" stretch>
      <el-tab-pane>
        <template #label>
          <span><i class="el-icon-user-solid"></i> 账号登录</span>
        </template>
        <login-account ref="accountRef" /> //获取到login-account组件
      </el-tab-pane>

    </el-tabs>

    <el-button class="loginBtn" type="primary" @click="handleLoginBtn">
      立即登录
    </el-button>
  </div>
</template>

<script lang="ts">
export default {

  setup() {
    const accountRef = ref()
    const handleLoginBtn = () => {
      // 拿到login-accoount组件中的loginAction方法
      accountRef.value.loginAction()
    }

    return {
      handleLoginBtn,
      accountRef //导出该变量，并绑定到组件上
    }
  }
}
</script>
```



经过上边的操作，已经实现了点击立即登录按钮，并立即触发其子组件中的loginAction方法

那么，loginAction方法是如何验证用户是否输入正确的呢？

```vue
<template>
  <div class="login-account">
    <el-form :rules="rules" :model="account" ref="formRef">
      <el-form-item label="账号" prop="name">
        <el-input v-model="account.name" />
      </el-form-item>

      <el-form-item label="密码" prop="password">
        <el-input v-model="account.password" />
      </el-form-item>
    </el-form>
  </div>
</template>

<script>
import { reactive, ref } from 'vue'

export default {
  setup() {
      
    const formRef = ref()
    const loginAction = () => {
      // 该方法用于验证用户输入是否符合下方规则
      // el-form可以里边有一个方法可以返回用户输入是否正确，所以这里需要拿到el-form
      formRef.value.validate((valid) => {
        //valid为true时，说明用户输入的账号密码没有问题
        if (valid) {
          console.log('账号密码输入格式正确，开始执行登录逻辑')
        }
      })
    }
    return {
      loginAction,
      formRef
    }
  }
}
</script>
```

事实上，el-form上存在着validate方法，当用户输入不正确时，返回false，反之true

所以，我们可以通过formRef获取到el-form，执行里边的validate方法。当validate返回true时，才真正进入登录逻辑，否则返回错误给用户

### 3.3 本地缓存

封装一个工具类，封装本地缓存的相关方法

```ts
//utils/cache.ts
// 本地缓存账号密码
class LocalCache {
  // 设置
  setCache(key, value) {
    window.localStorage.setItem(key,JSON.stringify(value))
  }
  // 获取缓存
  getCache(key) {
    const value = window.localStorage.getItem(key)
    if(value) {
      return JSON.parse(value)
    }
  }

  // 删除缓存
  deleteCache(key) {
    window.localStorage.removeItem(key)
  }

  // 清除缓存
  clearCache() {
    window.localStorage.clear()
  }
}

// 利用类，导出一个对象
export default new LocalCache()

```



根据用户是否点击了`isKeepPassword`来决定是否执行本地缓存。

所以，需要将`isKeepPassword`传递给login-account.vue组件

```vue
//login-panel.vue

<script>

export default defineComponent({
  setup() {
    const isKeepPassword = ref(true)

    const accountRef = ref()

    const handleLoginBtn = () => {
      // 拿到login-accoount组件中的loginAction方法
      accountRef.value?.loginAction(isKeepPassword.value)  //将‘记住密码’状态转递导子组件
    }

    return {}
  }
})
</script>
```

注：`<el-checkbox v-model="isKeepPassword">记住密码</el-checkbox>`

为el-checkbox绑定v-model可以改变其选中状态

```vue
<script>

import locaCache from '../../../utils/cache'

export default {
  setup() {


    const formRef = ref<Instanconsole.log()ceType<typeof ElForm>>()
    const loginAction = (isKeepPassword: boolean) => {
      formRef.value?.validate((valid) => {
        //valid为true时，说明用户输入的账号密码没有问题
        if (valid) {
          //1.判断是否需要记住密码
           	console.log(isKeepPassword)  //获取到记住密码的布尔值
          //2.进行登录逻辑

        }
      })
    }
    return {}
  }
}
</script>
```

上方的代码获取到了`isKeepPassword`的值，如果为true，则进行本地缓存



**知识点补充**

空值合并操作符（`??`）是一个逻辑操作符，当左侧的操作数为`null`或者`undefined`时，返回其右侧操作数，否则返回左侧操作数



具体的执行缓存的代码如下

```vue
<script>

import localCache from '../../../utils/cache'

export default{
  setup() {
    const account = reactive({
      // 获取到缓存里边的值
      name: ‘localCache.getCache('name') ?? '',
      password: localCache.getCache('password') ?? ''
    })

    const formRef = ref()
    const loginAction = (isKeepPassword: boolean) => {

      formRef.value.validate((valid) => {
        //valid为true时，说明用户输入的账号密码没有问题
        if (valid) {
          //1.判断是否需要记住密码
          if (isKeepPassword) {
            // 本地缓存
            localCache.setCache('name', account.name)
            localCache.setCache('password', account.password)
          } else {
            //记住密码未选中时
            localCache.deleteCache('name')
            localCache.deleteCache('password')
          }
        }
      })
    }
  }
}
</script>
```

### 3.4 登录验证

**1、区分手机登录还是账号登录**

当用户点击立即登录时，怎么区分它是手机登录还是账号登录

(在el-tabs中绑定v-model，在el-tab-pane绑定name ，通过el-tabs可以确定用户点击了哪个name)

```vue
<template>
  <div class="login-panel">
    <h1>后台管理系统</h1>
    <el-tabs v-model="currentTab">
        
      <el-tab-pane name="account">
      </el-tab-pane>

      <el-tab-pane name="phone">
      </el-tab-pane>

    </el-tabs>

  </div>
</template>

<script>
import { ref } from 'vue'
export default {


  setup() {
    //默认用户是账号登录
    const currentTab = ref('account')

    const handleLoginBtn = () => {
      if (currentTab.value === 'account') {
        accountRef.value.loginAction(isKeepPassword.value)
      } else {
        console.log('用户是手机登录，相关代码逻辑如下~')
      }
    }

    return {
      currentTab
    }
  }
}
</script>
```

这样一来，当用户选择账号登录，就执行login-account组件；当选择手机登录，就执行login-phone组件



**2、获取token等登录信息**

> name:coderwhy
>
> password :123456

将登录验证的相关信息存放在vuex里边（如token、userInfo等）

在vuex里边注册一个嵌套子模块login（实现的效果是：点击登录按钮，通过初步的账号密码验证后，进入这里进行登录验证）

```js
//子模块
const loginModule = {
  namespaced: true,
  state() {
    return {
      token: '',
      userInfo: {}
    }
  },
  mutations: {},
  actions: {
    accountLoginAction({ commit }, payload) {
      console.log('执行accountLoginAction', commit, payload)
    }
  }
}

export default loginModule
```

```js
//store/index.js
import { createStore } from 'vuex'
import login from './login/login'
const store = createStore({
  state() {
    return {
      name: 'linming'
    }
  },
  modules: {
    login //注册子模块
  }
})

export default store
```

在login-account.vue中触发这个子模块中的actions

```js
<script>
import { useStore } from 'vuex'
export default {
  setup() {
    //使用store
    const store = useStore()

    const account = reactive({
      name: localCache.getCache('name') ?? '',
      password: localCache.getCache('password') ?? ''
    })
    // 获取el-form，为了取得validate方法
    const formRef = ref()
    // 登录验证方法
    const loginAction = (isKeepPassword) => {
      // 可验证账号密码是否符合规则
      formRef.value.validate((valid) => {
        if (valid) {
          if (isKeepPassword) {
              
          // 开始执行登录验证
          store.dispatch('login/accountLoginAction', { ...account })
        }
      })
    }
```

`store.dispatch('login/accountLoginAction', { ...account })`触发actions

在actions中发送网络请求

```js
//service/login/login.js

import axios from 'axios'

export function loginAccount(account) {
  return axios({
    url: 'api/login',
    method: 'POST',
    data: account
  })
}
```

为解决跨域问题，需要到vue.config.js中进行配置

```js
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'http://152.136.185.210:5000',
        pathRewrite: {
          '^/api': ''
        },
        changeOrigin: true
      }
    }
  }
}
```

之后就可以在actions发送网络请求了。

获取到`name,password,token`，将token保存到state中

(注：修改state的唯一方式是提交mutations)

```js
//目录：store/login/login.js

import { loginAccount } from '../../service/login/login'

const loginModule = {
  namespaced: true,
  state() {
    return {
      token: '', //获取到token
      userInfo: {}
    }
  },
  mutations: {
    changeToken(state, token) {
      console.log(token)
      state.token = token
    }
  },
  actions: {
    async accountLoginAction({ commit }, payload) {
      // 1、发送网络请求
      const loginResult = await loginAccount(payload)

      const { token } = loginResult.data.data
      // 2、将token保存到state（注：需要先提交到mutations）
      commit('changeToken', token)
    }
  }
}

export default loginModule

```



**3、获取用户的详细信息**

根据用户的token、id获取用户详情。

请求路径url：`api/users/id`

这里利用本地缓存localStorage将token缓存下来，并在发送获取用户详情的loginInfoById函数中，将请求拦截下来，为其添加token，以达到身份验证的目的。

最后将获取到的userInfo保存到state中

```js
//网络请求
import { loginAccount, loginInfoById } from '../../service/login/login'
import localCache from '../../utils/cache'

const loginModule = {
  namespaced: true,
  state() {
    return {
      token: '',
      userInfo: ''
    }
  },
  mutations: {
    changeUserInfo(state, userInfo) {
      state.userInfo = userInfo //保存
    }
  },
  actions: {
      localCache.setCache('token', token) // token本地缓存

      // 2、将token保存到state（注：需要先提交到mutations）
      commit('changeToken', token)

      // 3.获取用户的详细信息
      const userInfoResult = await loginInfoById(id)
      const userInfo = userInfoResult.data.data

      // 4.将用户信息保存到state
      commit('changeUserInfo', userInfo)
    }
  }
}

export default loginModule

```

具体的网络请求如下

```js
import axios from 'axios'
import localCache from '../../utils/cache'

const token = localCache.getCache('token') //获取token

// 获取用户详细信息
export function loginInfoById(id) {
  axios.interceptors.request.use((config) => {
    if (token) {
      config.headers.Authorization = `Bearer ${token}` //将token传递进headers进行验证
    }
    return config
  })
  return axios({
    url: 'api/users/' + id
  })
}

```

**4、获取用户菜单**

不同权限的用户登录后有不同的菜单

```js
//store/login/login.js
      //5、获取用户菜单
      const userMenuRequest = await requestUserMenusByRoleId(userInfo.role.id)
      const userMenu = userMenuRequest.data.data
      console.log(userMenu)
	  commit('changeUserMenu', userMenu)
```

发送网络请求

```js
//目录：service/login/login.js

// 获取用户菜单
export function requestUserMenusByRoleId(id) {
  axios.interceptors.request.use((config) => {
    if (token) {
      config.headers.Authorization = `Bearer ${token}` //将token传递进headers进行验证
    }
    return config
  })
  return axios({
    url: 'api/role/' + id + '/menu'
  })
```

获取以上的数据之后,跳转到首页

```js
import router from '../../router/index'
// 6、跳转到首页
router.push('/main')
```



**5、实现未登录跳转到登录界面**

```js
//目录：router/index.js

// 导航守卫：判断登录的页面是否登录界面，不是就要判断有没有token
// 没有token，就要自动跳转到登录页面
router.beforeEach((to) => {
  if (to.path !== '/login') {
    const token = localCache.getCache('token')
    if (!token) {
      return '/login'
    }
  }
})
```



思考问题：vuex中的数据都是存在内存中的，登录进去了首页，点击刷新时，token、userInfo、userMenus都想被清除。怎么解决这个问题

思路:在sotre的index.js下创建一个setupStore函数，并在入口文件中调用，意味着每次刷新都会被执行一次，那么我们可以通过这个函数，重新将必要的信息重新保存进vuex的state中

```js
//目录：store/index.js

// 解决刷新数据vuex数据清除问题
export function setupStore() {
  store.dispatch('login/loadLocalLogin') //触发login中的action中的loadLocalLogin
}
```

```js
//目录：store/login/login.js
  actions: {
    // ....省略以上代码
      
    // 触发浏览器刷新时，重新将token，userInfo，userMenus缓存起来
    loadLocalLogin({ commit }) {
      const token = localCache.getCache('token')
      if (token) {
        commit('changeToken', token)
      }
      const userInfo = localCache.getCache('userInfo')
      if (userInfo) {
        commit('changeUserInfo', userInfo)
      }
      const userMenus = localCache.getCache('userMenus')
      if (userMenus) {
        commit('changeUserMenus', userMenus)
      }
    }
  }
}
```



### 四、菜单布局

### 4.1 基本结构

完成登录验证后，就可以对首页的内容展示进行操作了

根据element-plus的布局样式选择一款适合的，并编写css样式

```vue
//目录：main/main.vue
<template>
  <div class="main">
    <el-container class="main-content">
      <el-aside width="210px">
        <nav-menu></nav-menu>
      </el-aside>

      <el-container class="page">
        <el-header class="page-header">Header</el-header>
        <el-main class="page-content">Main</el-main>
      </el-container>
    </el-container>
  </div>
</template>
```

由于之后大量的组件都将在首页下展示，所以不能将所有组件都放在main文件夹下，应当抽取出去

在components中创建nav-munu文件夹，用于菜单展示的相关代码逻辑存放

**1、login展示**

```vue
//目录：conponents/nav-menu/nav-menu.vue
<template>
  <div class="nav-menu">
    <div class="logo">
      <img class="img" src="~@/assets/img/logo.svg" alt="logo" />
      <span v-if="!collapse" class="title">Vue3+TS</span>
    </div>
    </div>
</template>
```

注：在template中引用别名，需要加上'~'



**2、搭建菜单**

登录的时候，我们已经将菜单数据保存在vuex中了，现在可以userMenu中的信息判断用户权限，从而将相应的菜单渲染出来。

```js
//获取vuex中的数据
<script>
import { computed } from 'vue'
import { useStore } from 'vuex'
export default {
  setup() {
    const store = useStore()
    const userMenus = computed(() => store.state.login.userMenus)
    return {
      userMenus //可以在模板中使用了
    }
  }
}
</script>
```

根据element-plus的样式创建菜单

```vue
<template>
  <div class="nav-menu">
    <div class="logo">
      <img class="img" src="~@/assets/img/login/logo.svg" alt="logo" />
      <span class="title">Menu</span>
    </div>
    <!-- 菜单选项 -->
    <el-menu
      default-active="2"
      class="el-menu-vertical"
      background-color="#0c2135"
      text-color="#b7bdc3"
      active-text-color="#0a60bd"
    >
      <template v-for="item in userMenus" :key="item.id">
        <!-- 二级菜单 -->
        <template v-if="item.type === 1">
          <!-- 二级菜单的可以展开的标题 -->
          <el-submenu :index="item.id + ''">
            <template #title>
              <i v-if="item.icon" :class="item.icin"></i>
              <span>{{ item.name }}</span>
            </template>

            <!-- 遍历里面的item -->
            <template v-for="subitem in item.children" :key="subitem.id">
              <el-menu-item :index="subitem.id + ''">
                <i v-if="subitem.icon" :class="subitem.icon"></i>
                <span>{{ subitem.name }}</span>
              </el-menu-item>
            </template>
          </el-submenu>
        </template>
        <!-- 当有一级菜单时，显示一级菜单 -->
        <!-- 一级菜单 -->
        <template v-else-if="item.type === 2">
          <el-menu-item :index="item.id + ''">
            <i v-if="item.icon" :class="item.icon"></i>
            <span>{{ item.name }}</span>
          </el-menu-item>
        </template>
      </template>
    </el-menu>
  </div>
</template>
```



### 4.2 隐动态藏菜单

创建header相关逻辑的文件夹nav-header

并创建nav-header.vue，相关代码逻辑在里边实现

**1、切换的图标**

先来实现一个小功能，在header中添加一个小图标，点击时切换图标

```js
<template>
  <div class="nav-header">
    <i
      class="fold-Menu"
      :class="isFold ? 'el-icon-s-fold' : 'el-icon-s-unfold'"
      @click="ClickFoldIcon"
    ></i>
  </div>
</template>

<script>
import { ref } from 'vue'
export default {
  setup() {
    const isFold = ref(false)
    const ClickFoldIcon = () => {
      isFold.value = !isFold.value
    }
    return {
      isFold,
      ClickFoldIcon
    }
  }
}
</script>

<style scoped lang="less">
.nav-header {
  .fold-Menu {
    font-size: 35px;
    cursor: pointer; //将鼠标形状改为手指行
  }
}
</style>
```



**2、菜单伸缩功能**

点击nav-header组件中的图标，使nav-menu中的菜单组件收缩。可以在他们共同的父组件中实现

首先，点击图标，将点击事件传递给父组件

```vue
//在nav-header中
<script>
import { ref } from 'vue'
export default {
  emits: ['foldChange'],
  setup(props, { emit }) {
    const isFold = ref(false)
    const ClickFoldIcon = () => {
      isFold.value = !isFold.value
      emit('foldChange', isFold.value) //将点击图标时的事件传送给父组件main.vue
    } 
    return {
      isFold,
      ClickFoldIcon
    }
  }
}
</script>
```

在父组件中监听事件，并修改相应的菜单宽度

```js
<template>
  <div class="main">
    <el-container class="main-content">
      <el-aside :width="isCollapse ? '60px' : '210px'"> //利用三元运算符进行判断
        <nav-menu></nav-menu>
      </el-aside>

      <el-container class="page">
        <el-header class="page-header">
          <!-- 小图标 -->
          <nav-header @foldChange="foldChange" />
        </el-header>
        <el-main class="page-content">内容区</el-main>
      </el-container>
    </el-container>
  </div>
</template>
  setup() {
    const isCollapse = ref(false)
    const foldChange = (isFold) => {
      isCollapse.value = isFold 
    }
    return {
      foldChange,
      isCollapse
    }
  }
```

问题：菜单的整体收缩了，但是里边的内容没有收缩

解决：在el-menu组件中有一个属性可以控制菜单本身的收缩Collapse，默认为false

所以我们需要在父组件中将isCollapse的值传递给nav-menu组件

```js
//main.vue
        <!-- 菜单 -->
        <nav-menu :isCollapse="isCollapse" />
            
//nav-menu.vue
    <el-menu:collapse="isCollapse">
  props: {
    isCollapse: {
      type: Boolean,
      default: false
    }
```

同时最好的话，在收缩的过程中，文字给隐藏了



### 4.3 动态路由的映射

不同权限的用户看到的菜单是不一样的，所以在配置路由的时候，我们需要根据接口中的用户身份，注册不同的路由关系

首先，我们可以先将所有的页面先编写好，相应的路由信息也要编写完整(项目中有10个页面，所以一个需要在view中创建10个组件，以及在router中创建对应的10个路由配置的信息)

```vue
//以系统管理中的用户管理组件为例
//创建组件
<template>
  <div>user</div>
</template>

<script>
export default {}
</script>

<style scoped></style>
```

```js
//创建路由配置信息
const user = () => import('@/view/main/system/user/user.vue')
export default {
  path: '/main/system/user',
  name: 'user',
  component: user,
  children: []
}
```

当然，如果用户在url中随便输入时，最好也统一导航到NOT FOUND页面中。

这里可以额外配置一个not found 路由

```js
  {
    path: '/:pathMatch(.*)*',
    name: 'not-found',
    component: () => import('@/view/main/not-found/not-found.vue')
  }
```

**封装保存所有路由的函数**

具体思路如下：在登录时，我们将userMenus缓存在本地，userMenus保存了用户的权限信息。我们在view文件夹下创建的10个路径不会全部添加进main的子路由children中，而是要再store中进行筛选，如果userMenus中有相应的权限，则添加进去

我们需要封装一个函数来帮助我们进行筛选

```js
//utils/map-menus.js
export function mapMenusToRouters(userMenus) {
  const routes = []

  // 1.先加载默认所有的routes
  const allRoutes = []
  //webpack中的require.context可以找到指定目录下的所有js文件
  const routeFiles = require.context('../router/main', true, /\.js/)
  // routeFiles.keys()可以获得所有文路径的数组
  routeFiles.keys().forEach((key) => {
    const route = require('../router/main' + key.split('.')[1])
    allRoutes.push(route.default)
  })
  // 2.根据菜单获取需要添加的routes
  const _recurseGetRoute = (menus) => {
    for (const menu of menus) {
      if (menu.type === 2) {
        const route = allRoutes.find((route) => route.path === menu.url)
        if (route) routes.push(route)
      } else {
        _recurseGetRoute(menu.children)
      }
    }
  }
  _recurseGetRoute(userMenus)
  return routes
}

```

在store/login/login.js使用

将筛选的路由添加至main路由的子路由中

```js
  mutations: {
    changeUserMenus(state, userMenus) {
      state.userMenus = userMenus

      // 根据userMenus映射路由关系
      const routes = mapMenusToRouters(userMenus)
      console.log(routes)
      routes.forEach((route) => {
        router.addRoute('main', route) //将筛选的路由添加至main路由的子路由中
      })
    }
  },
```

为nav-menu中的选项添加点击事件，当点击对应的选项时，改变对应的路由

```js
<template>
  <div class="nav-menu">
      
    <!-- 菜单选项 -->
    <el-menu>
      <template v-for="item in userMenus" :key="item.id">
        <!-- 一级菜单 -->
        <template v-if="item.type === 1">
          <!-- 一级菜单的可以展开的标题 -->
          <el-submenu :index="item.id + ''">
            <template #title>
              <i v-if="item.icon" :class="item.icon"></i>
              <span>{{ item.name }}</span>
            </template>

            <!-- 遍历里面的一级菜单下的二级菜单 -->
            <template v-for="subitem in item.children" :key="subitem.id">
              <el-menu-item
                :index="subitem.id + ''"
                @click="handleMenuItemClick(subitem)" //将二级菜单info传递给点击函数
              >
                <i v-if="subitem.icon" :class="subitem.icon"></i>
                <span>{{ subitem.name }}</span>
              </el-menu-item>
            </template>
          </el-submenu>

        </template>
      </template>
    </el-menu>
  </div>
</template>

<script>
import { computed } from 'vue'
import { useStore } from 'vuex'
import { useRouter } from 'vue-router'
export default {
  props: {
    isCollapse: {
      type: Boolean,
      default: false
    }
  },
  setup() {
    const store = useStore()
    const userMenus = computed(() => store.state.login.userMenus)
    // 使用router
    const router = useRouter()

    const handleMenuItemClick = (item) => {
      // 点击时改变url
      router.push({
        //item.url为空或者undefined时，默认跳转到not-found页面
        path: item.url ?? '/not-found'
      })
    }
    return {
      userMenus,
      handleMenuItemClick
    }
  }
}
</script>
```

上边的代码中，点击二级菜单会改变对应的url，但是还未显示出对应的页面。需要在main.vue中进行使用

```js
<template>
  <div class="main">
        <!-- 菜单 -->

        <!-- 头部信息 -->

        <!-- 内容 -->
        <el-main class="page-content">
          <router-view></router-view>
        </el-main>
  </div>
</template>

```



## 五、nav-header

这一部分，左边是小图表+面包屑，右边是用户的进本信息

面包屑：即用户所在位置的一些信息



### 5.1 用户信息组件

创建一个用户信息的组件，并使用ui库中的相应的下拉选项组件

```js
//user-info.vue
<template>
  <el-dropdown :hide-on-click="false">
    <span class="el-dropdown-link">
      {{ userName }}<i class="el-icon-arrow-down el-icon--right"></i>
    </span>
    <template #dropdown>
      <el-dropdown-menu>
        <el-dropdown-item icon="el-icon-turn-off">系统管理</el-dropdown-item>
        <el-dropdown-item icon="el-icon-shopping-bag-1">
          商品中心</el-dropdown-item
        >
        <el-dropdown-item icon="el-icon-switch-button">
          退出登录</el-dropdown-item
        >
      </el-dropdown-menu>
    </template>
  </el-dropdown>
</template>

```

使用头像组件，并通过store将用户名取出来



### 5.2 面包屑

封装nav-breadcrube.vue组件

```js
<template>
  <div class="breadcrube">
    <el-breadcrumb separator="/">
      <el-breadcrumb-item :to="{ path: '/' }">首页</el-breadcrumb-item>
      <el-breadcrumb-item><a href="/">活动管理</a></el-breadcrumb-item>
      <el-breadcrumb-item>活动列表</el-breadcrumb-item>
      <el-breadcrumb-item>活动详情</el-breadcrumb-item>
    </el-breadcrumb>
  </div>
</template>

```

并在nav-header组件中引用





## 六、表单UI封装

### 6.1 基本结构

通过自己封装一个ui组件MzFrom.vue,可以方便地在每个页面中，通过传入一些简单的配置，塑造出想要的表单结构

```vue
<template>
  <div class="mz-from">
    <el-form label-width="100px">
      <el-row>
        <template v-for="item in formItems" :key="item.label">
          <el-col :span="8">
            <el-form-item :label="item.label">
              <!-- v-if决定是否展示文本输入，还是密码输入 -->
              <template
                v-if="item.type === 'input' || item.type === 'password'"
              >
                <el-input
                  :placeholder="item.placeholder"
                  :show-password="item.type === password"
                />
              </template>
              <!-- 决定是否展示多选框 -->
              <template v-else-if="item.type === 'select'">
                <el-select :placeholder="item.placeholder" style="width: 100%">
                  <el-option
                    v-for="option in item.options"
                    :key="option.value"
                    :value="option.value"
                    >{{ option.title }}</el-option
                  >
                </el-select>
              </template>
              <!-- 决定是否显示时间范围 -->
              <template v-else-if="item.type === 'datepicker'">
                <el-date-picker
                  style="width: 100%"
                  v-bind="item.otherOptions"
                ></el-date-picker>
              </template>
            </el-form-item>
          </el-col>
        </template>
      </el-row>
    </el-form>
  </div>
</template>

<script>
export default {
  // 根据外部配置决定渲染
  props: {
    formItems: {
      type: Array,
      default() {
        return []
      }
    }
  }
}
</script>

<style scoped></style>
```

这里的formItems，默认由外界提供。具体传入的内容如下

```vue
//user.vue
<template>
  <div class="user">
    <mz-from :formItems="formItems" />
  </div>
</template>

<script>
import MzFrom from '@/base-ui/MzFrom.vue'
export default {
  components: {
    MzFrom
  },
  setup() {
    const formItems = [
      {
        type: 'input',
        label: '用户名',
        placeholder: '请输入用户名'
      },
      {
        type: 'password',
        label: '密码',
        placeholder: '请输入密码'
      },
      {
        type: 'select',
        label: '爱好',
        placeholder: '请选择喜欢的运动',
        options: [
          { title: '篮球', value: 'basketball' },
          { title: '足球', value: 'football' }
        ]
      },
      {
        type: 'datepicker',
        label: '创建时间',
        otherOptions: {
          startPlaceholder: '开始时间',
          endPlaceholder: '结束时间',
          type: 'daterange'
        }
      }
    ]

    return {
      formItems
    }
  }
}
</script>
```

也可以为这个ui添加一些样式，label宽度,由外部决定他们的值

```js
//user.vue
<template>
  <div class="user">
    <mz-from
      :formItems="formItems"
      :labelWidth="labelWidth"
      :itemStyle="itemStyle"
    />
  </div>
</template>
	setup() {
    const labelWidth = '120px'
    const itemStyle = {
      padding: '10px 40px'
    }
    return {
      labelWidth,
      itemStyle
    }
  }
```

```vue
//mzfrom.vue
<script>
export default {
  // 根据外部配置决定渲染
  props: {
    // 基本配置
    formItems: {
      type: Array,
      default() {
        return []
      }
    },
    labelWidth: {
      type: String,
      default: '100px'
    },
    itemStyle: {
      type: Object,
      default() {
        return {
          padding: '10px 40px'
        }
      }
    }
  }
}
</script>
```

问题：我们会发现，在user.vue中为了配置这个表单UI，编写得很复杂。

其实我们可以将这些配置进行封装,将所有的配置写进一个fromconfig配置中

```vue
<template>
  <div class="user">
    <mz-from v-bind="fromConfig" />
  </div>
</template>

<script>
import MzFrom from '@/base-ui/MzFrom.vue'
export default {
  components: {
    MzFrom
  },
  setup() {
    const fromConfig = {
      labelWidth: '120px',
      itemStyle: {
        padding: '10px 40px'
      },
      formItems: [
        {
          type: 'input',
          label: 'id',
          placeholder: '请输入ID'
        },
        {
          type: 'input',
          label: '用户名',
          placeholder: '请输入用户名'
        },
        {
          type: 'password',
          label: '密码',
          placeholder: '请输入密码'
        },
        {
          type: 'select',
          label: '爱好',
          placeholder: '请选择喜欢的运动',
          options: [
            { title: '篮球', value: 'basketball' },
            { title: '足球', value: 'football' }
          ]
        },
        {
          type: 'datepicker',
          label: '创建时间',
          otherOptions: {
            startPlaceholder: '开始时间',
            endPlaceholder: '结束时间',
            type: 'daterange'
          }
        }
      ]
    }
    return {
      fromConfig
    }
  }
}
</script>

<style scoped></style>
```

甚至可以直接将user.vue中的配置单独封装到一个search.config.js文件中

然后统一在user.vue中导入使用即可

```vue
//user.vue
<template>
  <div class="user">
    <mz-from v-bind="searchFromConfig" />
  </div>
</template>

<script>
import MzFrom from '@/base-ui/MzFrom.vue'
// 导入配置表单UI配置文件
import { searchFromConfig } from './search.config'
export default {
  components: {
    MzFrom
  },
  setup() {
    return {
      searchFromConfig
    }
  }
}
</script>

<style scoped></style>
```



### 6.2 双向数据绑定

上边定义的表单是无法输入内容的，因为并没有绑定数据

在MzForm中新增一个formData对象，用于存放用户传递过来的数据

```js
 props: {
    // 数据信息
    formData: {
      type: Object,
      required: true //必传
    },
        //....
 }
```



因为每个页面v-model将要绑定的值是不一样的，所以我们可以在所在页面向UI组件中传入需要绑定的值

```vue
//user.vue
<template>
  <div class="user">
    <mz-from :formData="formData" />
  </div>
</template>

<script>
import { reactive } from 'vue'
export default {
  components: {
    MzFrom
  },
  setup() {
    // 表单信息
    const formData = reactive({
      id: '',
      name: '',
      password: '',
      sport: '',
      createTime: ''
    })

    return {
      formData
    }
  }
}
</script>
```

向search.config.js中的每一项新增一个属性：如‘请输入用户名’对象，增加一项：` field: 'name'`

之后就可以为每一个表单项进行双向数据绑定了

```vue
//MzForm.vue
                <el-input v-model="formData[`${item.field}`]" />



### 6.3 插槽

为UI组件增加header、footer两个位置而定插槽

其中header主要用来自定义表单标题，footer用来进行重置表单，或者进行搜索

​```js
//在form-UI中增加两个插槽
<template>
  <div class="mz-from">
    <!-- 头部插槽 -->
    <slot name="header"></slot>

    <el-form></el-form>

    <!-- 尾部插槽 -->
    <slot name="footer"></slot>
  </div>
</template>
```

在用户页面根据具体需求，填充插槽

```vue
<template>
  <div class="user">
    <mz-from v-bind="searchFromConfig" :formData="formData">
      <!-- 头部插槽 -->
      <template #header>
        <h2 class="form-title">高级检索</h2>
      </template>
      <!-- 尾部插槽 -->
      <template #footer>
        <div class="form-button">
          <el-button>重置</el-button>
          <el-button type="primary">搜索</el-button>
        </div>
      </template>
    </mz-from>
  </div>
</template>
```



### 6.3 重置和搜索

由于代码user.vue中的代码没有进行封装，相关的保存数据、重置搜索按钮等操作都集中在这个页面中，所以操作都可以在这个页面进行

重置只需要将formData中的数据清空，如果下方的表格数据已经被修改，需要重新发送网络请求，使其回复正常

```vue
//user.vue

	<mz-from v-bind="searchFromConfig" :formData="formData">

      <!-- 尾部插槽 -->
      <template #footer>
        <div class="form-button">
          <el-button @click="handleResetClick">重置</el-button>
          <el-button type="primary" @click="handleQueryClick">搜索</el-button>
        </div>
      </template>
    </mz-from>

<script>
    // 重置表单
    const handleResetClick = () => {
        //将原先双向绑定的数据清空
      formData.id = ''
      formData.name = ''
      formData.realname = ''
      formData.cellphone = ''
      formData.enable = ''
      formData.createAt = ''
      // 点击重置时，返回原来的搜索结果
      getPageInfo() //重新调用发送保存数据到store中的操作
    }
</script>
```

因为接口允许我们额外接收一些数据，比如name=‘w’,它会自动搜索name为w的所有用户，所以我们可以为网络请求传入额外的参数

```js
    // store
    const store = useStore()
    const getPageInfo = (formData = {}) => {
      store.dispatch('system/getPageListAction', {
        pageUrl: 'users/list',
        queryInfo: {
          offset: 0,
          size: 10,
          ...formData
        }
      })
    }
    getPageInfo()
```

当用户点击搜索按钮，将表单项中填写的数据加到网络请求后边，这样子请求下来的数据就是符合搜索要求的

```js
    // 搜索按钮逻辑
    const handleQueryClick = () => {
      getPageInfo(formData)
    }
```





## 七、 表格UI封装

### 7.1 数据请求

之前表单的数据在登录的时候就已经请求保存在vuex中了，但是用户表格信息、部分信息等等，都需要单独去请求。

这里同样用vuex来进行保存

```js
//创建store/main/system/system.js文件
const systemModule = {
  namespaced: true,
  state() {
    return {
      userList: [],
      userCount: 0
    }
  },
  actions: {
    getPageListAction(payload) {
      console.log(payload) //在这里发起网络请求
    }
  }
}

export default systemModule
```

需要在其父模块中注册一

```js
import { createStore } from 'vuex'
import system from './main/system/system'
const store = createStore({
  state() {
    return {}
  },
  modules: {
    system //注册
  }
})
export default store
```

以请求user信息为例

```vue
//user.vue

<script>
import { useStore } from 'vuex'
export default {

  setup() {
    // store
    const store = useStore()
    store.dispatch('system/getPageListAction', {
      pageUrl: 'users/list',
      queryInfo: {
        offset: 0,
        size: 10
      }
    })
  }
}


```

经过以上的步骤，基本的数据请求的结构已经搭建好了

现在需要向vuex中的system.js文件导入数据了

所以需要封装发送网络请求的函数

```js
//service/main/system/system.js
// 请求system菜单的信息

import axios from 'axios'
//获取本地缓存的token
import localCache from '../../../utils/cache'

const token = localCache.getCache('token')

export function getPageListData(url, queryInfo) {
  axios.interceptors.request.use((config) => {
    if (token) {
      config.headers.Authorization = `Bearer ${token}` //将token传递进headers进行验证
    }
    return config
  })
  return axios.post('api/' + url, queryInfo)
}
```

在vuex中system.js中的actions使用上方异步函数，发送网络请求获取数据，并将数据保存到state中

```js
// 网络请求
import { getPageListData } from '../../../service/main/system/system'
const systemModule = {
  namespaced: true,
  state() {
    return {
      userList: [],
      userCount: 0
    }
  },
  mutations: {
    getUserList(state, list) {
      state.userList = list
    },
    getUserCount(state, totalCount) {
      state.userCount = totalCount
    }
  },
  actions: {
    async getPageListAction(context, payload) {
      // 路径信息与参数信息
      const res = await getPageListData(payload.pageUrl, payload.queryInfo)
      const { list, totalCount } = res.data.data
      context.commit('getUserList', list)
      context.commit('getUserCount', totalCount)
    }
  }
}

export default systemModule
```

### 7.2 搭建表格

```vue
//user.vue
    <!-- 表格 -->
    <div class="page-table">
      <el-table :data="userList" style="width: 100%">
        <template v-for="propItem in propList" :key="propItem.prop">
          <el-table-column
            :prop="propItem.prop"
            :label="propItem.label"
            :min-width="propItem.minWidth"
          >
          </el-table-column>
        </template>
      </el-table>
    </div>

//el-table-column表示一列，prop对应的数据，label显示表头，min-width表头宽度

<script>
  setup() {
    // computed 请求菜单用户信息
    const userList = computed(() => store.state.system.userList)
    const userCount = computed(() => store.state.system.userCount)
    const propList = [
      { prop: 'name', label: '用户名', minWidth: '100' },
      { prop: 'realname', label: '真实姓名', minWidth: '100' },
      { prop: 'cellphone', label: '手机号码', minWidth: '100' },
      { prop: 'enable', label: '状态', minWidth: '100' },
      { prop: 'createAt', label: '创建时间', minWidth: '250' },
      { prop: 'updateAt', label: '更新时间', minWidth: '250' }
    ]
    return {
      userList,
      userCount,
      propList
    }
  }
</script>
```

将表单结构单独抽离出去

```vue
//Mzform.vue
<template>
  <div>
    <div class="page-table">
      <el-table :data="userList" style="width: 100%">
        <template v-for="propItem in propList" :key="propItem.prop">
          <el-table-column
            :prop="propItem.prop"
            :label="propItem.label"
            :min-width="propItem.minWidth"
            align="center"
          >
          </el-table-column>
        </template>
      </el-table>
    </div>
  </div>
</template>

<script>
export default {
  props: {
    propList: {
      type: Array,
      required: true
    },
    userList: {
      type: Array,
      required: true
    }
  }
}
</script>

<style scoped>
/* 表格部分 */
.page-table {
  padding: 20px;
  border-top: 20px solid #f5f5f5;
}
</style>

```



### 7.4 插入作用域插槽

在MzForm中插入插槽

```vue
      <el-table :data="userList" style="width: 100%">
        <template v-for="propItem in propList" :key="propItem.prop">
          <el-table-column
            :prop="propItem.prop"
            :label="propItem.label"
            :min-width="propItem.minWidth"
            align="center"
          >
            <!-- 默认插槽 -->
            <template #default="scope">
              <slot :name="propItem.slotName" :row="scope.row">
                {{ scope.row[propItem.prop] }}
              </slot>
            </template>
          </el-table-column>
        </template>
      </el-table>
```

在user.vue中进行相关配置

```js
    <!-- 表格 -->
    <mz-table :userList="userList" :propList="propList">
      <!-- 每个template可单独修改一列 -->
      <template #status="scope">
        <el-button>{{ scope.row.enable ? '启用' : '禁用' }}</el-button>
      </template>
      <template #createAt="scope">
        <strong>{{ scope.row.createAt }}</strong>
      </template>
    </mz-table>
```

注：需要在propList增加一个slotName的字段



### 7.4 格式化utc时间

可以发现在table表中，时间是乱序的。

之后会需要大量用到格式化时间的方法，所以可以统一在全局中封装一个时间格式化方法

以下是简单的使用

```js
//main.js
// app中config中的globalProperties允许注册全局的方法
app.config.globalProperties.$filter = {
  formatTime(value) {
    return '2021-08-1 05:20:20' + value
      //编写具体的格式啊代码
  }
}
```



为了更具有封装性,简化入口文件代码，可以将其封装到global中,并导出到index.js中

```js
//register-properties.js
export default function (app) {
  // app中config中的globalProperties允许注册全局的方法
  app.config.globalProperties.$filter = {
    formatTime(value) {
      return '2021-08-1 05:20:20' + value
    }
  }
}
```



具体的格式化函数借助于dayjs可以很容易实现

`npm install dayjs`

```js
//在utils/data-format.js
import dayjs from 'dayjs'
import utc from 'dayjs/plugin/utc'

// 使该库支持转化uct
dayjs.extend(utc)

export function formatUtcString(utcString, format) {
  format = 'YYYY-MM-DD HH:mm:ss'
  return dayjs.utc(utcString).format(format)
}
```

使用utc时间格式化函数

```js
//register-properties.js
import { formatUtcString } from '../utils/data-format'

export default function (app) {
  // app中config中的globalProperties允许注册全局的方法
  app.config.globalProperties.$filter = {
    formatTime(value) {
      return formatUtcString(value)
    }
  }
}
```

### 7.5 其他补充

增加两列：序号列，选择列

```vue
//MzTable.vue
      <el-table :data="userList" style="width: 100%">
        <el-table-column
          v-if="seletionColumn"
          type="selection"
          width="60"
          align="center"
        ></el-table-column>
        <el-table-column
          v-if="showIndexColumn"
          type="index"
          label="序号"
          align="center"
          width="60"
        ></el-table-column>
          
          <el-table-column</el-table-column> //省略部分代码
      </el-table>
```

el-table上边有一个事件`selection-change`可以监听选择列的某一项被选中,我们可以将该时间发发送出去，由使用它的父组件user.vue执行响应的操作

```vue
//MzTable.vue
<el-table @selection-change="handleSelectionChange"> </el-table>
<script>
  emits: ['SelectionChange'],
  setup(props, { emit }) {
    const handleSelectionChange = (value) => {
      emit('SelectionChange', value)
    }
    return {
      handleSelectionChange
    }
  }
</script>
```

在使用者user.vue中进行监听

```vue
<mz-table @SelectionChange="handleSelectionChange"> </mz-table>

<script>
    // handleSelectionChange
    const handleSelectionChange = (value) => {
      console.log('触发了', value)
    }
</script>
```



**通过插槽增加操作列**

在user.vue中增加操作

```vue
    <!-- 表格 -->
    <mz-table
      :userList="userList"
      :propList="propList"
      @SelectionChange="handleSelectionChange"
    >
      <!-- 每个template可单独修改一列 -->
      <template #handler>
        <div class="handle-btns">
          <el-button icon="el-icon-edit" size="mini" type="text"
            >编辑</el-button
          >
          <el-button icon="el-icon-delete" size="mini" type="text"
            >编辑</el-button
          >
        </div>
      </template>
    </mz-table>


<script>
export default {

  setup() {

    const propList = [
        //.....
      { label: '操作', minWidth: '120', slotName: 'handler' }
    ]

  }
```



**抽取表格配置代码**

可以看到，为了配置MzForm，user.vue中增加了大量的配置代码，我们可以将这部分代码抽取出去

```js
//创建contetn.config.js
export const contentTableConfig = {
  propList: [
    { prop: 'name', label: '用户名', minWidth: '100' },
    { prop: 'realname', label: '真实姓名', minWidth: '100' },
    { prop: 'cellphone', label: '手机号码', minWidth: '100' },
    { prop: 'enable', label: '状态', minWidth: '100', slotName: 'status' },
    {
      prop: 'createAt',
      label: '创建时间',
      minWidth: '250',
      slotName: 'createAt'
    },
    {
      prop: 'updateAt',
      label: '更新时间',
      minWidth: '250',
      slotName: 'updateAt'
    },
    { label: '操作', minWidth: '120', slotName: 'handler' }
  ],
  handleSelectionChange: (value) => {
    console.log('触发了', value)
  },
  title: '用户列表'
}
```

在user.vue中通过v-bind将该对象直接绑定到Mz-form组件上

```vue
<mz-table :userList="userList" v-bind="contentTableConfig"></mz-table>
```









### 7.6 header和footer

**1、header的代码逻辑**

```vue
//在MzTable中加入头部插槽
      <!-- 表格头部(插槽) -->
      <div class="header">
        <!-- 默认插槽 -->
        <slot name="header">
          <div class="title">{{ title }}</div>
          <div class="handler">
            <slot name="headerHandler"></slot>
          </div>
        </slot>
      </div>
```

默认的标题插槽在使用该组件的时候会自动显示。其中的标题可以由使用者传递进来

所以，user.vue中的代码可以很简洁

```vue
      <mz-table :title="title">
		<!-- 表格头部 -->
      <template #headerHandler>
        <el-button type="primary" size="medium">创建用户</el-button>
      </template>
	  </mz-table>
```





**2、footer的代码逻辑**

首先对Element-plus框架进行国际化，因为默认的样式时显示英文的，包括日历，分页上的文字显示

```vue
//App.vue
<template>
  <div id="app">
    <!-- 国际化 -->
    <el-config-provider :locale="locale">
      <router-view></router-view>
    </el-config-provider>
  </div>
</template>

<script>
import { ElConfigProvider } from 'element-plus'
import zhCn from 'element-plus/lib/locale/lang/zh-cn'
export default {
  name: 'App',
  components: {
    ElConfigProvider
  },
  data() {
    return {
      zhCn
    }
  }
}
</script>
```

在页面中使用ui库中的分页

```vue
//MzTable.vue
      <!-- 表格尾部（插槽） -->
      <div class="footer">
        <slot name="footer">
          <el-pagination
            @size-change="handleSizeChange"
            @current-change="handleCurrentChange"
            :current-page="currentPage4"
            :page-sizes="[100, 200, 300, 400]"
            :page-size="100"
            layout="total, sizes, prev, pager, next, jumper"
            :total="400"
          >
          </el-pagination>
        </slot>
      </div>
```



### 7.7 分页

```vue
//MzTble.vue
      <!-- 表格尾部（插槽） -->
      <div class="footer">
        <slot name="footer">
          <el-pagination
            @size-change="handleSizeChange"
            @current-change="handleCurrentChange"
            :current-page="page.currentPage"
            :page-sizes="[10, 20, 30, 40]"
            :page-size="page.pageSize"
            layout="total, sizes, prev, pager, next, jumper"
            :total="userCount"
          >
          </el-pagination>
        </slot>
      </div>
```

我们需要对`current-page`和`page-size`进行双向数据绑定

并修改`getPageInfo`为动态的

```js
    // 双向绑定分页组件中的内容
    const pageInfo = ref({
      currentPage: 0,
      pageSize: 10
    })
    watch(pageInfo, () => getPageInfo())
    // store
    const store = useStore()
    const getPageInfo = (formData = {}) => {
      store.dispatch('system/getPageListAction', {
        pageUrl: 'users/list',
        queryInfo: {
          offset: pageInfo.value.currentPage * pageInfo.value.pageSize,
          size: pageInfo.value.pageSize,
          ...formData
        }
      })
    }

```

```vue
//mz-table
<script>
export default {
  props: {
    page: {
      type: Object,
      default: () => {
        return {
          currentPage: 0,
          pageSize: 10
        }
      }
    }
  },
  emits: ['SelectionChange', 'update:page'],
  setup(props, { emit }) {

    const handleCurrentChange = (currentPage) => {
      emit('update:page', { ...props.page, currentPage })
    }
    const handleSizeChange = (pageSize) => {
      emit('update:page', { ...props.page, pageSize })
    }
    return {
      handleSizeChange,
      handleCurrentChange
    }
  }
}
</script>
```



## 八、ECharts 

### 8.1 基本认识

ECharts ，一个基于 JavaScript 的开源可视化图表库

**什么是数据可视化呢？**

为了清晰有效地传递信息，数据可视化使用统计图形、图表、信息图表和其他工具，以使用点、线或条，对数字数据进行编码，让我们可以更加清晰的去认识、理解、表达数据。



**前端可视化工具**

+ 常见的框架： ECharts 、g2、d3、vis、hightChart等等

+ 地理可视化： g2、L7、高德的Loca、 菜鸟的鸟图

+ 3D可视化：three.js



**ECharts的特点** 

+ 丰富的图表类型：提供开箱即用的 20 多种图表和十几种组件，并且支持各种图表以及组件的任意组合

+ 强劲的渲染引擎：Canvas、SVG 双引擎一键切换，增量渲染、流加载等技术实现千万级数据的流畅交互

+ 专业的数据分析：通过数据集管理数据，支持数据过滤、聚类、回归，帮助实现同一份数据的多维度分析

+ 优雅的可视化设计：默认设计遵从可视化原则，支持响应式设计，并且提供了灵活的配置项方便开发者定制

+ 健康的开源社区：活跃的社区用户保证了项目的健康发展，也贡献了丰富的第三方插件满足不同场景的需求

+ 友好的无障碍访问：智能生成的图表描述和贴花图案，帮助视力障碍人士了解图表内容，读懂图表背后的故事



### 8.2 基本使用

1、安装：`npm install echarts --save`

2、引入ECharts

`import * as echarts from 'echarts'`

3、初始化Echarts对象，并且设置配置进行绘制

```vue
<script>
import * as echarts from 'echarts'
import { ref } from 'vue'
export default {
  setup() {
    const divRef = ref()
    const echartInstance = echarts.init(divRef.value)
    const option = {} //具体的图表数据逻辑
    echartInstance.setOption(option)
    return {
      divRef
    }
  }
}
</script>
```

A.通过`echarts.init(dom, theme, options)`初始化

B.通过`setOption`方法设置绘制的数据

注：这里使用`divRef`是为了获取dom，且`divRef`必须定义高度



**完整案例展示**

```vue
<template>
  <div class="dashboard">
    <div ref="divRef" :style="{ width: '500px', height: '400px' }"></div>
  </div>
</template>

<script>
import * as echarts from 'echarts'
import { ref, onMounted } from 'vue'
export default {
  setup() {
    const divRef = ref()
    onMounted(() => {
      const echartInstance = echarts.init(divRef.value)
      const option = {
        title: {
          text: 'ECharts 入门示例'
        },
        tooltip: {},
        legend: {
          data: ['销量']
        },
        xAxis: {
          data: ['衬衫', '羊毛衫', '雪纺衫', '裤子', '高跟鞋', '袜子']
        },
        yAxis: {},
        series: [
          {
            name: '销量',
            type: 'bar',
            data: [5, 20, 36, 10, 10, 20]
          }
        ]
      }
      echartInstance.setOption(option)
    })

    return {
      divRef
    }
  }
}
</script>
```

注：`const echartInstance = echarts.init(divRef.value,theme)`初始化时传入的第二个参数可以改变图表的主题。仅有`light`与`dark`两种可选



### 8.3 canvas与svg

通常在渲染图表时我们会选择SVG或canvas进行渲染，这两种渲染模式比较相近，并且可以相互替换。但是在一些场景中，他们的表现和能力有一定的差异

**差别**

1、一般来说，canvas更适合绘制图形元素数量非常大的图标（如热力图，地理坐标图等），也利于实现某些视觉特效

2、但是，SVG也具有重要的优势：它的内存占用更低（在移动端表现优异），渲染性能略高，并且是矢量图，缩放不会失真。



**指定渲染器**

在初始化时，就可以选择要使用的渲染器了

```js
const echartsInstance = echarts.init(dom, 'dart', {
    renderer: 'svg'
})
```



### 8.4 常见属性分析

```js
const option = {
        title: {//标题
          text: '标题文本',
          subText:"子标题"
        },
        tooltip: {}, //鼠标移动到对应元素上的样式
        legend: { //图例
          data: ['销量'] 
        },
        xAxis: { //x轴文本
          data: ['衬衫', '羊毛衫', '雪纺衫', '裤子', '高跟鞋', '袜子']
        },
        yAxis: {}, //y轴刻度可不写，根据series的data自动推导
        series: [
          {
            name: '销量', //图例文本
            type: 'bar', // 图标类型
            data: [5, 20, 36, 10, 10, 20] //x轴数据
          }
        ]
      }
```



## 九、小工具

### 9.1 生成uid

安装：`npm install nanoid`

使用：

```js
import { nanoid } from 'nanoid'
let idA = nanoid()

//指定生成字符串长度
let idB = nanoid(6)
```



自定义字母或大小

```js
import { customAlohabet } from 'nanoid'
//随机8位0-9字母
const nanoid = customAlohabet('1234567890', 8)
let id = nanoid()
```











