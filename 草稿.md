# 草稿



## 一、虚拟滚动

大数据数据量处理思路：

+ 时间分片
+ 虚拟滚动



### 1.1 虚拟列表

**普通虚拟滚动**

```vue
<template>
    <div class="container" ref="virtualList">
        <!-- 占位元素 -->
        <div class="phantom" :style="{ height: listHeight + 'px' }"></div>
        <!-- 渲染区域 -->
        <div class="content" :style="{ transform: `translate3d(0, ${currentOffset}px, 0)` }">
            <div v-for="item in visibleData" :key="item.id" :style="{ height: itemSize + 'px' }" class="list-item">
                {{ item.value }}
            </div>
        </div>
    </div>
</template>

<script>
import _ from "lodash";
export default {
    data() {
        return {
            listData: [],
            itemSize: 50,
            screenHeight: 0,
            currentOffset: 0,
            start: 0,
            end: 0,
        };
    },
    mounted() {
        for (let i = 1; i <= 1000; i++) {
            this.listData.push({ id: i, value: "字符内容" + i });
        }
        this.screenHeight = this.$el.clientHeight;
        this.start = 0;
        this.end = this.start + this.visibleCount;
        this.$refs.virtualList.addEventListener("scroll", (event) => this.scrollEvent(event.target));
    },
    computed: {
        listHeight() {
            return this.listData.length * this.itemSize;
        },
        // 渲染区域元素数量
        visibleCount() {
            return Math.ceil(this.screenHeight / this.itemSize);
        },
        visibleData() {
            return this.listData.slice(this.start, this.end);
        },
    },
    methods: {
        scrollEvent(target) {
            const scrollTop = target.scrollTop;
            this.start = ~~(scrollTop / this.itemSize);
            this.end = this.start + this.visibleCount;
            this.currentOffset = scrollTop - (scrollTop % this.itemSize);
        },
    },
};
</script>

<style scoped>
.container {
    position: relative;
    height: 90vh;
    overflow: auto;
}
/* .phantom {
    position: absolute;
    top: 0;
    right: 0;
    left: 0;
} */
.content {
    position: absolute;
    top: 0;
    right: 0;
    left: 0;
    text-align: center;
}
.list-item {
    padding: 10px;
    border: 1px solid #999;
}
</style>
```



**动态高度虚拟列表**

```js
<template>
    <div class="wrapper" ref="wrapper">
        <div class="placeholder-dom" :style="{ height: `${listHeight}px` }"></div>
        <div class="content" :style="{ transform: `translate3d(0, ${virtualList.currentOffset}px, 0)` }">
            <div v-for="item in showData" :key="item.id" :id="item.id" class="list-item" ref="listItem">
                {{ item.value }}
            </div>
        </div>
    </div>
</template>

<script setup>
/**
 * @description
 * @author
 * @version 0.0.1
 * @creatDate 2023/07/17
 */
// data
const listData = ref([]);
const virtualList = reactive({
    positions: [],
    preItemSize: 50, //预估高度
    start: 0,
    end: 0,
    clientHeight: 0, //wrapper高度
    currentOffset: 0, //偏移量
});
const wrapper = ref();
const listItem = ref();

const getData = () => {
    for (let i = 1; i <= 100; i++) {
        listData.value.push({ id: i - 1, value: i + "字符内容".repeat(Math.random() * 20) });
    }
};
getData();

// 总高度
const listHeight = computed(() => virtualList.positions[virtualList.positions.length - 1].bottom);
// 展示数据
const showData = computed(() => listData.value.slice(virtualList.start, virtualList.end));
// 展示个数
const count = computed(() => Math.ceil(virtualList.clientHeight / virtualList.preItemSize));

// 初始化预估高度数组
const initPositions = (listData, preItemSize) => {
    virtualList.positions = listData.map((item, index) => ({
        index,
        top: index * preItemSize,
        bottom: (index + 1) * preItemSize,
        height: preItemSize,
    }));
};
initPositions(listData.value, virtualList.preItemSize);

onMounted(() => {
    // 监听滚动事件
    if (wrapper.value) {
        virtualList.clientHeight = wrapper.value.clientHeight;
        virtualList.start = 0;
        virtualList.end = virtualList.start + count.value;
        wrapper.value.addEventListener("scroll", handleScroll);
    }
});

onUpdated(() => {
    nextTick(() => {
        // console.log("页面发生了渲染，更新");
        updatePositions();
        getCurrentOffset();
    });
});

const handleScroll = (e) => {
    const scrollTop = e.target.scrollTop;
    virtualList.start = getStartIndex(scrollTop);
    virtualList.end = virtualList.start + count.value;
    virtualList.currentOffset = scrollTop;
};

// 动态计算listHeight：showData在滚动过程中不断触发update事件
// 计算渲染后的DOM元素的高度，并将其覆盖预估的高度
const updatePositions = () => {
    // console.log(virtualList.positions);
    listItem.value &&
        listItem.value.forEach((node) => {
            // 获取 真实DOM高度
            const { height } = node.getBoundingClientRect();
            // 根据 元素索引 获取 缓存列表对应的列表项
            let index = node.id * 1;
            const oldHeight = virtualList.positions[index].height;
            // dValue：真实高度与预估高度的差值 决定该列表项是否要更新
            let dValue = oldHeight - height;
            virtualList.positions[index].bottom = virtualList.positions[index].bottom - dValue;
            virtualList.positions[index].height = height;
            // 依次更新positions中后续元素的 top bottom
            for (let k = index + 1; k < virtualList.positions.length; k++) {
                virtualList.positions[k].top = virtualList.positions[k - 1].bottom;
                virtualList.positions[k].bottom = virtualList.positions[k].bottom - dValue;
            }
        });
    // console.log(virtualList.positions);
};

// =======================tools fn=============================
const getStartIndex = (scrollTop) => {
    let item = virtualList.positions.find((item) => item.bottom > scrollTop);
    if (item) {
        return item.index;
    }
};

// 重新获取偏移量
const getCurrentOffset = () => {
    if (virtualList.start >= 1) {
        virtualList.currentOffset = virtualList.positions[virtualList.start - 1].bottom;
    } else {
        virtualList.currentOffset = 0;
    }
};
</script>

<style lang="less" scoped>
.wrapper {
    position: relative;
    height: 90vh;
    overflow: auto;

    .content {
        position: absolute;
        left: 0;
        top: 0;
        .list-item {
            padding: 10px;
            border: 1px solid #999;
        }
    }
}
</style>

```



### 1.2 antdVue table

基于a-table的实现方式

**固定高度滚动**

```vue
<template>
    <a-table :dataSource="showData" :columns="columns" :pagination="false" :scroll="{ y: 550 }" />
</template>

<script setup>
import { columns } from "./config/table.config";
import { mockData } from "./config/mock.config";

const data = ref([]);
const virtualList = reactive({
    start: 0,
    end: 15,
    count: 15,
    itemHeight: 55,
    scrollTop: 0,
    wrapperDom: null,
    contentDom: null,
});

//模拟请求获取数据
const getDataList = async () => {
    data.value = await mockData(10000, 100);
};
getDataList();

//动态展示的数据
const showData = computed(() => data.value?.slice(virtualList.start, virtualList.end) || []);
    
// 确保data有数据，并且能够获取到DOM节点后初始化
watch(data, () => {
    data.value.length && init();
});

//初始化虚拟滚动
const init = () => {
    virtualList.wrapperDom = document.querySelector(".ant-table-body");
    virtualList.contentDom = document.querySelector(".ant-table-body table");
    if (!virtualList.wrapperDom || !virtualList.contentDom) return;

    virtualList.wrapperDom.style.position = "relative";
    virtualList.wrapperDom.style.top = virtualList.wrapperDom.style.left = "0";
    virtualList.contentDom.style.position = "absolute";
    virtualList.wrapperDom.addEventListener("scroll", handleScroll);

    // 创建支撑起高度的div
    let isExist = document.querySelector(".palceholder-dom");
    if (isExist) return;
    const placeHolderDom = document.createElement("div");
    placeHolderDom.className = "palceholder-dom";
    virtualList.wrapperDom.appendChild(placeHolderDom);
    placeHolderDom.style.height = data.value.length * virtualList.itemHeight + "px";
};

//触发滚动
const handleScroll = () => {
    virtualList.scrollTop = virtualList.wrapperDom.scrollTop;
    virtualList.start = Math.ceil(virtualList.wrapperDom.scrollTop / virtualList.itemHeight);
    virtualList.end = virtualList.start + virtualList.count;
    virtualList.contentDom.style.top = virtualList.wrapperDom.scrollTop + "px";
};
</script>
```



**不定高度**

基于a-table的滚动,封装为hook

```js
import { useThrottleFn, useDebounceFn } from "@vueuse/core";
/**
 * antdVue table虚拟滚动
 * @param {*} data
 * @returns
 */
export const useVirtualList = (dataLen, config, isUpdated) => {
    let { start, end, className, preItemSize } = config || {};

    const virtualList = reactive({
        start,
        end,
        className,
        currentOffset: 0,
        wrapperDom: null,
        contentDom: null,
        placeHolderDom: null,
        positions: [],
        preItemSize,
    });

    virtualList.count = end - start;
    className = `${virtualList.className ? "." + virtualList.className + " " : ""}`;

    // 初始化预估高度数组
    const initPositions = (dataLen, preItemSize) => {
        virtualList.positions = new Array(dataLen).fill(undefined).map((_item, index) => ({
            index,
            top: index * preItemSize,
            bottom: (index + 1) * preItemSize,
            height: preItemSize,
        }));
    };
    initPositions(dataLen, virtualList.preItemSize);

    // 总高度
    const listHeight = computed(() => virtualList.positions[virtualList.positions.length - 1].bottom);

    const init = () => {
        virtualList.wrapperDom = document.querySelector(`${className}.ant-table-body`);
        virtualList.contentDom = document.querySelector(`${className}.ant-table-body table`);
        if (!virtualList.wrapperDom || !virtualList.contentDom) return;

        virtualList.wrapperDom.style.position = "relative";
        virtualList.wrapperDom.style.top = virtualList.wrapperDom.style.left = "0";
        virtualList.contentDom.style.position = "absolute";
        // 防抖处理
        const limitScrollFn = useThrottleFn(handleScroll, 20);
        virtualList.wrapperDom.addEventListener("scroll", limitScrollFn);

        // 占位
        let isExist = document.querySelector(`${className}.palceholder-dom`);
        if (isExist) return;
        const placeHolderDom = document.createElement("div");
        placeHolderDom.className = "palceholder-dom";
        virtualList.wrapperDom.appendChild(placeHolderDom);

        // 初始化预估总高度
        placeHolderDom.style.height = listHeight.value + "px";
        virtualList.placeHolderDom = placeHolderDom;
    };

    watch(isUpdated, () => {
        updatePositions();
        // 更新完缓存列表后，重新赋值偏移量
        refreshCurrentOffset();
        virtualList.contentDom.style.transform = `translateY(${virtualList.currentOffset}px)`;
        virtualList.placeHolderDom.style.height = listHeight.value + "px";
    });
    const handleScroll = () => {
        const scrollTop = virtualList.wrapperDom.scrollTop;
        virtualList.start = getStartIndex(scrollTop);
        virtualList.end = virtualList.start + virtualList.count;
        virtualList.currentOffset = scrollTop - (scrollTop % virtualList.preItemSize);
        virtualList.contentDom.style.transform = `translateY(${virtualList.currentOffset}px)`;
    };

    // 动态计算listHeight：showData在滚动过程中不断触发update事件
    // 计算渲染后的DOM元素的高度，并将其覆盖预估的高度
    const updatePositions = () => {
        const listItems = document.querySelectorAll(`${className}.ant-table-body table .ant-table-row`);
        listItems &&
            listItems.forEach((node) => {
                const { height } = node.getBoundingClientRect();
                // 根据 元素索引 获取 缓存列表对应的列表项
                let index = node.dataset?.rowKey * 1;
                const oldHeight = virtualList.positions[index].height;
                // dValue：真实高度与预估高度的差值 决定该列表项是否要更新
                let dValue = oldHeight - height;
                if (dValue) {
                    // 更新对应列表项的 bottom 和 height
                    virtualList.positions[index].bottom = virtualList.positions[index].bottom - dValue;
                    virtualList.positions[index].height = height;
                    // 依次更新positions中后续元素的 top bottom
                    for (let k = index + 1; k < virtualList.positions.length; k++) {
                        virtualList.positions[k].top = virtualList.positions[k - 1].bottom;
                        virtualList.positions[k].bottom = virtualList.positions[k].bottom - dValue;
                    }
                }
            });
    };

    // 重新获取偏移量
    const refreshCurrentOffset = () => {
        if (virtualList.start >= 1) {
            virtualList.currentOffset =
                virtualList.positions[virtualList.start - 1].bottom -
                (virtualList.currentOffset % virtualList.preItemSize);
        } else {
            virtualList.currentOffset = 0;
        }
    };

    // 匹配到第一个大于当前scrollTop的数组作为start起始的元素
    const getStartIndex = (scrollTop) => {
        return binarySearch(virtualList.positions, scrollTop);
    };

    nextTick(() => {
        // 数据量过少时，不应用虚拟滚动
        if (dataLen > virtualList.count) init();
    });

    return virtualList;
};

// 二分查询
let binarySearch = function (list, target) {
    const len = list.length;
    let left = 0,
        right = len - 1;
    let tempIndex = null;

    while (left <= right) {
        let midIndex = (left + right) >> 1;
        let midVal = list[midIndex].bottom;

        if (midVal === target) {
            return midIndex;
        } else if (midVal < target) {
            left = midIndex + 1;
        } else {
            // list不一定存在与target相等的项，不断收缩右区间，寻找最匹配的项
            if (tempIndex === null || tempIndex > midIndex) {
                tempIndex = midIndex;
            }
            right--;
        }
    }
    // 如果没有搜索到完全匹配的项 就返回最匹配的项
    return tempIndex;
};
```

使用方式

```js
const showData = computed(() => data.value?.slice(virtualList.value.start, virtualList.value.end) || []);
watch(data, () => {
    virtualList.value = useVirtualList(
        data.value.length,
        { start: 0, end: 12, itemHeight: 55, preItemSize: 60 },
        isUpdated,
    );
});
const isUpdated = ref(1);
onUpdated(() => {
    nextTick(() => {
        isUpdated.value++;
    });
});
```

