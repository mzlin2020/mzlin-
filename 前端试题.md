# 前端试题

## 1、函数作用域

1、说出下面题目的输出

```js

var a = 1;
(() => {
    console.log(a);
    a = 2;
})();
//输出 1，查找到全局 a  
 
var a = 1;
(() => {
    // 相当于a提升在这里=>  var a;
    console.log(a);
    var a = 2; 
})();
//输出 undefined，变量声明提升 
 
var a = 1;
(() => {
    console.log(a);
    let a = 2;
})();
//输出 报错 原因：在初始化之前无法访问a
```

## 2、闭包题

1、下面代码执行结果？不用let怎么让他输出想要的结果?

```js
for(var i=0;i<6;i++){
    setTimeout(function(){
        console.log(i)
    },1000);
}
```

使用闭包

```js
for(var i=0;i<6;i++){
    setTimeout(function(i){
        return function(){
            console.log(i);
        }
    }(i),1000);
}
```





##  3、栈

### 3.1 包含min函数的栈

 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。 

思路：在存储数据的栈A外，再建一个栈B用于存储最小值

具体：栈B如何存储最小值：除了第一个入栈的元素，之后每一个入栈元素都与栈底元素对比，小于等于栈底元素入栈，否则不入栈

```js
class MinStack {
    constructor() {
        this.stackA = [] 
        this.stackB = []
        this.countA = 0
        this.countB = 0
    }

    push(element) {
        this.stackA[this.countA++] = element
        // 栈B为空时，入栈
        // 新增小于等于stackB元素，入栈
        if(this.countB === 0 || element <= this.min()) {
            this.stackB[this.countB++] = element
        }
    }

    min() {
        return this.stackB[this.countB - 1]
    }
    top() {
        return this.stackA[this.countA - 1]
    }
    pop() {
        // 栈A与栈B的栈顶元素相同，才删除
        if(this.min() === this.top()) {
            delete this.stackB[--this.countB]
        }
        delete this.stackA[--this.countA]
    }
}
```



方式二：利用js内置的方法Math.min

缺点：性能上比第一种方法差一些

```js
class MinStack{
    constructor() {
        this.stack = []
    }
    push(element) {
        this.stack.push(element)
    }
    min() {
        return Math.min.apply(null, this.stack)
    }
    pop() {
        this.stack.pop()
    }
}
    
```







