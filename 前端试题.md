# 前端试题

```js
@title '前端试题'
@description '前端常见问题汇总'
@image 'https://gw.alipayobjects.com/zos/rmsportal/JiqGstEfoWAOHiTxclqi.png'
```

## 1、函数作用域

1、说出下面题目的输出

```js
var a = 1;
(() => {
  console.log(a);
  a = 2;
})();
//输出 1，查找到全局 a

var a = 1;
(() => {
  // 相当于a提升在这里=>  var a;
  console.log(a);
  var a = 2;
})();
//输出 undefined，变量声明提升

var a = 1;
(() => {
  console.log(a);
  let a = 2;
})();
//输出 报错 原因：在初始化之前无法访问a
```

## 2、闭包题

1、下面代码执行结果？不用 let 怎么让他输出想要的结果?

```js
for (var i = 0; i < 6; i++) {
  setTimeout(function () {
    console.log(i);
  }, 1000);
}
```

使用闭包

```js
for (var i = 0; i < 6; i++) {
  setTimeout(
    (function (i) {
      return function () {
        console.log(i);
      };
    })(i),
    1000
  );
}
```

## 3、栈

### 3.1 包含 min 函数的栈

定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

思路：在存储数据的栈 A 外，再建一个栈 B 用于存储最小值

具体：栈 B 如何存储最小值：除了第一个入栈的元素，之后每一个入栈元素都与栈底元素对比，小于等于栈底元素入栈，否则不入栈

```js
class MinStack {
  constructor() {
    this.stackA = [];
    this.stackB = [];
    this.countA = 0;
    this.countB = 0;
  }

  push(element) {
    this.stackA[this.countA++] = element;
    // 栈B为空时，入栈
    // 新增小于等于stackB元素，入栈
    if (this.countB === 0 || element <= this.min()) {
      this.stackB[this.countB++] = element;
    }
  }

  min() {
    return this.stackB[this.countB - 1];
  }
  top() {
    return this.stackA[this.countA - 1];
  }
  pop() {
    // 栈A与栈B的栈顶元素相同，才删除
    if (this.min() === this.top()) {
      delete this.stackB[--this.countB];
    }
    delete this.stackA[--this.countA];
  }
}
```

方式二：利用 js 内置的方法 Math.min

缺点：性能上比第一种方法差一些

```js
class MinStack {
  constructor() {
    this.stack = [];
  }
  push(element) {
    this.stack.push(element);
  }
  min() {
    return Math.min.apply(null, this.stack);
  }
  pop() {
    this.stack.pop();
  }
}
```

### 3.2 十进制转二进制

```js
class Stack {
  constructor() {
    this.stack = [];
    this.count = 0;
  }

  push(element) {
    this.stack[this.count++] = element;
  }
  isEmpty() {
    return this.count === 0;
  }
  pop() {
    if (this.isEmpty()) {
      console.log("栈为空");
    }
    const temp = this.stack[this.count - 1];
    delete this.stack[this.count - 1];
    this.count--;
    return temp;
  }
}

function dec2bin(originNum) {
  const s = new Stack();

  while (originNum > 0) {
    s.push(originNum % 2);

    originNum = Math.floor(originNum / 2);
  }
  let res = "";
  while (!s.isEmpty()) {
    res += s.pop() + "";
  }
  return res;
}
```

## 4、队列

### 4.1 击鼓传花

**击鼓传花**

击鼓传花是一个常见的面试算法题 ，使用队列可以非常方便的实现最终的结果

原游戏规则：班级玩一个游戏，所有学生围成一圈，从某位同学手里开始向旁边的传花，当鼓声停下时，花在谁手里，谁就出列

**修改游戏规则**

几个朋友一起玩游戏，围成一圈，开始数数，数到某个数字的人淘汰，最后剩下的人获得胜利，请问最后剩下的是原来在哪一个位置上的人？

封装队列类

```javascript
// 封装队列类
function Queue() {
  // 属性
  this.items = [];

  // 1.将元素添加到队列中
  Queue.prototype.enqueue = function (element) {
    this.items.push(element);
  };

  //2.将元素从队列前端删除并返回
  Queue.prototype.dequeue = function () {
    return this.items.shift();
  };

  //3.返回队列的长度
  Queue.prototype.size = function () {
    return this.items.length;
  };

  //4.读取队列的前端元素
  Queue.prototype.front = function () {
    return this.items[0];
  };
}
```

解析

```javascript
// 面试题：击鼓传花
//nameList表示参加游戏的人名组成的数组，num表示指定的被淘汰的数字
function pastGame(nameList, num) {
  // 1.创建一个队列结构
  var queue = new Queue();

  // 将所有人加入到队列中
  for (var i = 0; i < nameList.length; i++) {
    queue.enqueue(nameList[i]);
  }

  // 3.开始数数字
  while (queue.size() > 1) {
    //队列中的元素小于等于1时，就会停下来
    // 不是num时，重新加入队列尾部
    // 是num，则将其删除
    for (var i = 0; i < num - 1; i++) {
      queue.enqueue(queue.dequeue()); //num数字之前ed人重新放入队列末尾
    }
    //num对应的人，从队列中删除
    queue.dequeue();
  }

  //读取队列剩下来的元素
  return queue.front();
}

var arr = ["小明", "小红", "小强", "小王", "小刚", "小李"];
var res = pastGame(arr, 3);
console.log(res); //1 最终剩下的人是小明 0
```

###

### 4.2 队列的最大值

请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数 max_value、push_back 和 pop_front 的均摊时间复杂度都是 O(1)。

若队列为空，pop_front 和 max_value 需要返回 -1

思路：创建一个队列 Q 和一个双端队列 D。每次添加值时进行判断，是否添加值大于 D 的队尾值，大于则删除队尾值直到小于队尾值，插入队尾。这样以来，D 就维持了单调递减的规律。

```js
var MaxQueue = function () {
  this.queue = {};
  this.deque = {};
  this.countQ = this.headQ = this.countD = this.headD = 0;
};

// 队尾入队
MaxQueue.prototype.push_back = function (value) {
  // 原始队列直接入队
  this.queue[this.countQ++] = value;

  // 双端队列入队规则
  // 新增值大于deque的队尾值
  while (!this.isDequeEmpty() && value > this.deque[this.countD - 1]) {
    delete this.deque[--this.countD];
  }
  this.deque[this.countD++] = value;
};

// 队首出队
MaxQueue.prototype.pop_front = function () {
  if (this.isQueueEmpty()) return -1;
  // 判断queue与deque队首值是否相等，相等删除也要删除deque队首
  if (this.deque[this.headD] === this.queue[this.headQ]) {
    delete this.deque[this.headD++];
  }
  const queueData = this.queue[this.headQ];
  delete this.queue[this.headQ++];
  return queueData;
};

// 最大值
MaxQueue.prototype.max_value = function () {
  if (this.isQueueEmpty()) return -1;
  return this.deque[this.headD];
};

// deque是否为空
MaxQueue.prototype.isDequeEmpty = function () {
  return !(this.countD - this.headD);
};
// queue是否为空
MaxQueue.prototype.isQueueEmpty = function () {
  return this.countQ - this.headQ === 0;
};
```

## 5、链表

### 5.1 反转链表

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

**示例:**

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

```js
function reverseList(head) {
  const cur = head;
  const prev = null;

  while (cur) {
    const next = cur.next;
    cur.next = prev;
    prev = cur;
    cur = next;
  }
  return prev;
}
```

## 6、数组与字符串

### 6.1 合并两个有序数组

题号：88

解题方法：逆向双指针

思路：

> 设置两个指针 p1 和 p2，代表当前正在处理中的 nums1 或 nums2 的位置。每次应用后减 1
>
> 以及当前正在处理的元素位置 tail，每次成功处理后减 1
>
> 遍历比较两者大小，大的数往 tail 所代表的 nums 的位置存放

```js
const merge = function (
  nums1: number[],
  m: number,
  nums2: number[],
  n: number
) {
  let p1 = m - 1;
  let p2 = n - 1;
  let tail = m + n - 1;
  let cur: number | undefined;
  while (p1 >= 0 || p2 >= 0) {
    if (p1 === -1) {
      cur = nums2[p2--];
    } else if (p2 === -1) {
      cur = nums1[p1--];
    } else if (nums1[p1] < nums2[p2]) {
      cur = nums2[p2--];
    } else {
      cur = nums1[p1--];
    }
    nums1[tail--] = cur;
  }
};
```

### 6.2 移除数组

题号：27

解题方法：双指针

解题思路：题目仅检验左边数组的正确性，顺序不限。所以可以用 left 指针指向当前要处理的元素位置，right 指针进行遍历。当`nums[right]`不等于 val 时，将其移动至 left 的位置，left 加一

```js
function removeElement(nums: number[], val: number): number {
  let left = 0; //指向当前要处理的元素位置
  for (let right = 0; right < nums.length; right++) {
    if (nums[right] !== val) {
      nums[left] = nums[right];
      left++;
    }
  }
  return left;
}
```

### 6.3 删除有序数组中的重复项

题号：26

解题方法： 双指针

解题思路：题目仅检验左边数组的正确性。利用 slow 指针指向当前处理的元素（由于第 1 位始终是最小的，所以 slow = 1 ），fast 指针从第二项开始遍历，如果大于前一项则将其替换掉 slow 的位置的元素

```js
function removeDuplicates(nums: number[]): number {
  let slow = 1;
  for (let fast = 1; fast < nums.length; fast++) {
    if (nums[fast - 1] < nums[fast]) {
      nums[slow++] = nums[fast];
    }
  }
  return slow;
}
```

### 6.4 删除有序数组中的重复项 2

题号：80

解题方法：双指针

解题思路：定义快慢双指针，慢指针指向当前需要处理的元素(由于前两项要么不同要么相同，符合条件，可以从第三项处理起)，快指针进行遍历。当且仅当 nums[fast] = nums[slow - 1] = nums[slow - 2]，说明当前的 slow 值已存在两次，可以不进行处理。

```js
function removeDuplicates(nums: number[]): number {
  if (nums.length < 2) return nums.length;

  let slow = 2;
  for (let fast = 2; fast < nums.length; fast++) {
    if (nums[slow - 2] !== nums[fast] || nums[slow - 1] !== nums[fast]) {
      nums[slow] = nums[fast];
      slow++;
    }
  }
  return slow;
}
```

### 6.5 多数元素

题号：169

解决方法：统计次数、排序、投票算法

**方式一 ： 排序**

解题思路：既然总数一定大于数组 length 的 1/2，那么通过排序后中位数所在的位置一定就是众数。偶数长度：n / 2; 奇数长度：Math.floor(n/2)

```js
function majorityElement2(nums: number[]): number {
  nums.sort((a, b) => a - b);
  return nums[Math.floor(nums.length / 2)];
}
```

**方式二：投票算法**

解题思路：如果把众数记为 +1，把其他数记为 -1，将它们全部加起来，显然和大于 0，从结果本身可以看出众数比其他数多(对照生活中的投票现象会变得很好理解)

```js
function majorityElement(nums: number[]): number {
  let candidate: number | null = null;
  let count = 0;
  for (let i = 0; i < nums.length; i++) {
    if (count === 0) candidate = nums[i];
    candidate === nums[i] ? count++ : count--;
  }
  return candidate as number;
}
```

### 6.6 轮转数组

题号：189

解决方法：新建一个数组存储、翻转数组

**方式一：翻转数组**

解题思路：将原数组按照不同的位置翻转 3 次

```js
const reverse = (nums: number[], start: number, end: number): void => {
  while (start < end) {
    let temp = nums[start];
    nums[start] = nums[end];
    nums[end] = temp;
    start++;
    end--;
  }
};

function rotate(nums: number[], k: number): void {
  k = k % nums.length;
  reverse(nums, 0, nums.length - 1);
  reverse(nums, 0, k - 1);
  reverse(nums, k, nums.length - 1);
}
```

### 6.7 买股票的最佳时机

题号：121

解决方法：双循环暴力解法、一次遍历

**方式一：一次遍历**

解题思路：最大的收益永远符合以下规则：历史最低价与后来天数中的最高阶的差值。所以只要在一次循环中匹配到最低价，再往后遍历到`profit < prices[i] -minPrice`即是最大收益

```js
function maxProfit(prices: number[]): number {
  let minPrice = prices[0]; //历史最低价格
  let profit = 0; //最大收益

  for (let i = 0; i < prices.length; i++) {
    if (prices[i] < minPrice) {
      minPrice = prices[i];
    } else if (prices[i] - minPrice > profit) {
      profit = prices[i] - minPrice;
    }
  }

  return profit;
}
```

### 6.8 买股票的最佳时机 2

题号：122

解决方法：遍历计算差值

解题思路：最大利润为每次能够取得的差值相加

```js
function maxProfit(prices: number[]): number {
  let result = 0;
  for (let i = 1; i < prices.length; i++) {
    if (prices[i - 1] < prices[i]) {
      result += prices[i] - prices[i - 1];
    }
  }
  return result;
}
```


### 6.9 跳跃游戏

题号：55

解决方法：贪心算法

解题思路：遍历数组，计算可到达元素的向右跳的最大值(i + nums[i])。遍历过程中如何确定元素可达：i <= rightMost。当且仅当向右跳的最大元素rightMost大于数组的长度时，说明最后一个元素可达

```js
function canJump(nums: number[]): boolean {
  let rightMost = 0; //当前向右跳的最大值
  for (let i = 0; i < nums.length; i++) {
    if (i <= rightMost) {
      rightMost = Math.max(rightMost, i + nums[i]);
      if (rightMost >= nums.length - 1) return true;
    }
  }
  return false;
}
```
